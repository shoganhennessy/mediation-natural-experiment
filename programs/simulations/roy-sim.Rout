
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> #!/usr/bin/R
> ## Senan Hogan-Hennessy, 16 Jan 2025
> ## Simulate the system for indirect + direct effects, with Roy selection.
> # Show the date:
> print(format(Sys.time(), "%H:%M %Z %A, %d %B %Y"))
[1] "16:21 EST Wednesday, 05 February 2025"
> 
> ## Load libraries
> # Functions for data manipulation and visualisation
> library(tidyverse)
── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──
✔ dplyr     1.1.4     ✔ readr     2.1.5
✔ forcats   1.0.0     ✔ stringr   1.5.1
✔ ggplot2   3.5.1     ✔ tibble    3.2.1
✔ lubridate 1.9.3     ✔ tidyr     1.3.1
✔ purrr     1.0.2     
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors
> # Library for better colour choice.
> library(ggthemes)
> # Library for equations in plots
> library(latex2exp)
> # Causal medation package, Imai Keele Yamamoto (2010)
> library(mediation)
Loading required package: MASS

Attaching package: ‘MASS’

The following object is masked from ‘package:dplyr’:

    select

Loading required package: Matrix

Attaching package: ‘Matrix’

The following objects are masked from ‘package:tidyr’:

    expand, pack, unpack

Loading required package: mvtnorm
Loading required package: sandwich
mediation: Causal Mediation Analysis
Version: 4.5.0

> # Package for classical selection estimators (i.e., MLE)
> library(sampleSelection)
Loading required package: maxLik
Loading required package: miscTools

Please cite the 'maxLik' package as:
Henningsen, Arne and Toomet, Ott (2011). maxLik: A package for maximum likelihood estimation in R. Computational Statistics 26(3), 443-458. DOI 10.1007/s00180-010-0217-1.

If you have questions, suggestions, or comments regarding the 'maxLik' package, please use a forum or 'tracker' at maxLik's R-Forge site:
https://r-forge.r-project.org/projects/maxlik/
> # Package for semi-parametric regressor
> library(splines)
> 
> ## Set up the R environment
> #set.seed(47)
> # Define number of digits in tables and graphs
> digits.no <- 3
> # Define where output files go.
> output.folder <- file.path("sim-output")
> # Set the options for the plot sizes, in saving ggplot output.
> fig.height <- 10
> fig.width <- fig.height
> 
> # Define the sample size to work with.
> sample.N <- 10^4
> 
> 
> ################################################################################
> ## Define a function to simulate data in the triangular system.
> 
> # Define a function to simulate all observed + unobserved data 
> simulate.data <- function(rho, sigma_0, sigma_1, sigma_C,
+         sample.size = sample.N){
+     ### Inputs:
+     ## X, a matrix of covariates, continuous or binary values.
+     ## rho \in [-1, +1] measuring correlation between U_0, U_1.
+     ## sigma_0 >= 0 measuring standard deviation of U_0.
+     ## sigma_1 >= 0 measuring standard deviation of U_1.
+     ## sigma_C >= 0 measuring standard deviation of U_C.
+     ## sample.size: integer, representing output sample size i.e., N.
+     # First covariate (\vec X_i^-)
+     X_minus <- 4 + rnorm(sample.size, mean = 0, sd = 1)
+     # Second covariate (instrument for the control function).
+     X_IV <- rbinom(sample.size, 1, 1 / 2)
+     # Simulate the unobserved error terms.
+     U_both <- MASS::mvrnorm(
+         n = sample.size,
+         mu = c(0, 0, 0),
+         Sigma = matrix(c(
+             sigma_0^2,                rho * sigma_0 * sigma_1,  0,
+             rho * sigma_0 * sigma_1,  sigma_1^2,                0,
+             0,                        0,                        sigma_C^2), ncol = 3),
+         empirical = FALSE)
+     U_0 <- U_both[, 1]
+     U_1 <- U_both[, 2]
+     U_C <- U_both[, 3]
+     # Define the mean potential outcomes.
+     mu_outcome_z_d_X <- function(z, d, x_minus){
+         return(x_minus + (z + d + z * d))
+     }
+     mu_cost_z_X <- function(z, x_minus, x_iv){
+         return(- 3 * z + x_minus - x_iv)
+     }
+     # Y_i(Z, D) = mu_D(Z; X_i) + U_D
+     Y_0_0 <- mu_outcome_z_d_X(0, 0, X_minus) + U_0
+     Y_0_1 <- mu_outcome_z_d_X(0, 1, X_minus) + U_1
+     Y_1_0 <- mu_outcome_z_d_X(1, 0, X_minus) + U_0
+     Y_1_1 <- mu_outcome_z_d_X(1, 1, X_minus) + U_1
+     # D_i(Z)= 1{ Y(Z, 1) - Y(Z, 0) >= C_i }
+     D_0 <- as.integer(Y_0_1 - Y_0_0 >= mu_cost_z_X(0, X_minus, X_IV) + U_C)
+     D_1 <- as.integer(Y_1_1 - Y_1_0 >= mu_cost_z_X(1, X_minus, X_IV) + U_C)
+     # Generate the individual effects (direct + indirect)
+     probZ <- 0.5
+     Z <- rbinom(sample.size, 1, probZ)
+     # Observed outcomes: D, Y
+     D <- (Z * D_1) + ((1 - Z) * D_0)
+     # Generate the list of observed outcomes
+     Y <- (Z * D * Y_1_1) +
+         (Z * (1 - D) * Y_1_0) +
+         ((1 - Z) * D * Y_0_1) +
+         ((1 - Z) * (1 - D) * Y_0_0)
+     # Put these data to a coherent data frame.
+     combined.data <- data.frame(
+         # Observed data
+         Z, D, Y,  X_minus, X_IV,
+         # Unobserved, potential outcomes and compliance.
+         D_0, D_1,
+         Y_0_0, Y_0_1, Y_1_0, Y_1_1,
+         #mu0_Z0_X, mu1_Z0_X, mu0_Z1_X, mu1_Z1_X, muC_Z0_X, muC_Z1_X, 
+         U_0, U_1, U_C)
+     # Return the simulated data as a data frame.
+     return(combined.data)
+ }
> 
> 
> ################################################################################
> ## Define a function to show the theoretical values for the data.
> theoretical.values <- function(sim.data, digits.no = 3, print.truth = FALSE){
+     ### Inputs:
+     ## sim.data, a data frame simulated from above.
+     # Extract the potentials from simulated data.
+     Z <- sim.data$Z
+     D <- sim.data$D
+     Y <- sim.data$Y
+     X_minus <- sim.data$X_minus
+     X_IV <- sim.data$X_IV
+     D_0 <- sim.data$D_0
+     D_1 <- sim.data$D_1
+     Y_0_0 <- sim.data$Y_0_0
+     Y_0_1 <- sim.data$Y_0_1
+     Y_1_0 <- sim.data$Y_1_0
+     Y_1_1 <- sim.data$Y_1_1
+     U_0 <- sim.data$U_0
+     U_1 <- sim.data$U_1
+     U_C <- sim.data$U_C
+     # Get the true first-stage effects
+     first_stage <- D_1 - D_0
+     average_first_stage <- mean(first_stage)
+     # Get the theoretical total effect/reduced form/ITT
+     total_effect <-
+         (Y_1_1 - Y_0_0) * (D_1 == 1 & D_0 == 0) +
+         (Y_1_1 - Y_0_1) * (D_1 == 1 & D_0 == 1) +
+         (Y_1_0 - Y_0_0) * (D_1 == 0 & D_0 == 0)
+     average_total_effect <- mean(total_effect)
+     # Get the theoretical indirect effect.
+     indirect_effect <-
+         (Z * (Y_1_1 - Y_1_0) + (1 - Z) * (Y_0_1 - Y_0_0)) * (D_1 == 1 & D_0 == 0)
+     average_indirect_effect <- mean(indirect_effect)
+     # Get the theoretical direct effect.
+     direct_effect <- #(D * (Y_1_1 - Y_0_1) + (1 - D) * (Y_1_0 - Y_0_0))
+         (D * (Y_1_1 - Y_0_1) + (1 - D) * (Y_1_0 - Y_0_0)) * (D_1 == 1 & D_0 == 0) +
+         (Y_1_1 - Y_0_1) * (D_1 == 1 & D_0 == 1) +
+         (Y_1_0 - Y_0_0) * (D_1 == 0 & D_0 == 0)
+     average_direct_effect <- mean(direct_effect)
+     # Show the real underlying values.
+     if (print.truth == TRUE){
+         print("Here is a summary of the (unobserved) true effects:")
+         # Show how many ATs, NTs, Compliers in terms of D_i(Z) for Z = 0, 1.
+         print("How many compliers in the system?")
+         print(table(D_1, D_0) / NROW(sim.data))
+         # Show the real treatment effects
+         print(paste0(c("The average total effect:",    as.numeric(average_total_effect))))
+         print(paste0(c("The average first-stage:",     as.numeric(average_first_stage))))
+         print(paste0(c("The average direct effect:",   as.numeric(average_direct_effect))))
+         print(paste0(c("The average indirect effect:", as.numeric(average_indirect_effect))))
+     
+     }
+     # Define a named list to return
+     output.list <- list(
+         average_first_stage     = average_first_stage,
+         average_total_effect    = average_total_effect,
+         average_direct_effect   = average_direct_effect,
+         average_indirect_effect = average_indirect_effect)
+     # Return the output.list
+     return(output.list)
+ }
> 
> ################################################################################
> ## Define a function to estimate mediation, given the first + second-stages.
> 
> # Estimate the values, given a first and second-stages
> estimated.values <- function(firststage.reg, secondstage.reg, example.data){
+     ### Inputs:
+     ## example.data, a data frame simulated from above.
+     # calculate the first-stage by prediction
+     firststage.est <- predict(
+         firststage.reg, newdata = mutate(example.data, Z = 1), type = "response") - predict(
+             firststage.reg, newdata = mutate(example.data, Z = 0), type = "response")
+     # calculate the second-stage direct effect
+     direct.est <- predict(
+         secondstage.reg, newdata = mutate(example.data, Z = 1)) -
+         predict(secondstage.reg, newdata = mutate(example.data, Z = 0))
+     # calculate the second-stage indirect effect
+     indirect.est <- predict(
+         secondstage.reg, newdata = mutate(example.data, D = 1)) -
+         predict(secondstage.reg, newdata = mutate(example.data, D = 0))
+     # Add on the K_0, K_1 conditional on D_i = 0, 1 respectively for compliers.
+     # Estimate the kappa-weight
+     hat_probZ <- 0.5
+     kappa_1 <- example.data$D * ((example.data$Z - hat_probZ) / (
+         (1 - hat_probZ) * hat_probZ))
+     kappa_0 <- (1 - example.data$D) * (((1 - example.data$Z) - (1 - hat_probZ)) / (
+         (1 - hat_probZ) * hat_probZ))
+     kappa.weight <- kappa_1 * hat_probZ + kappa_0 * (1 - hat_probZ)
+     # Calculate the term to add on.
+     add.term <- (weighted.mean(predict(secondstage.reg, newdata = mutate(
+         filter(example.data, D == 1), Z = 0, D = 0, X_minus = 0, K_0 = 0)),
+             kappa.weight[example.data$D == 1])
+         - weighted.mean(predict(secondstage.reg, newdata = mutate(
+             filter(example.data, D == 0), Z = 0, D = 0, X_minus = 0, K_1 = 0)),
+                 kappa.weight[example.data$D == 0]))
+     indirect.est <- indirect.est + add.term
+     # Return the mean estimates.
+     output.list <- list(
+         "first-stage"     = mean(firststage.est),
+         "direct-effect"   = mean(direct.est),
+         "indirect-effect" = mean(firststage.est * indirect.est))
+     # Return the output.list
+     return(output.list)
+ }
> 
> # Bootstrap the estimates.
> estimated.loop <- function(boot.reps, example.data,
+         sample.size = sample.N, bootstrap = TRUE){
+     # Define lists the will be returned:
+     # 2. Naive OLS.
+     ols_direct_effect <- c()
+     ols_indirect_effect <- c()
+     # 3. Control function.
+     cf_direct_effect <- c()
+     cf_indirect_effect <- c()
+     # More in the future ....
+     ## Loop across the bootstraps values.
+     for (i in seq(1, boot.reps)){
+         # If bootstrapping, just resample from provided data.
+         if (bootstrap == TRUE) {
+             boot.indicies <- sample(seq(1, sample.size), sample.size, replace = TRUE)
+             boot.data <- example.data[boot.indicies, ]
+         }
+         # If a regular re-simulation, get new data.
+         else if (bootstrap == FALSE){
+             boot.data <- simulate.data(0.5, 1, 2, 0.25)
+             if ((100 * (i / boot.reps)) %% 1 == 0) {
+                 print(paste0(i, " out of ", boot.reps, ", ", 100 * (i / boot.reps), "% done."))
+             }
+         }
+         else {stop("The `bootstrap' option only takes values of TRUE or FALSE.")}
+         # Calculate the truth values, given the simulated data
+         truth.est <- theoretical.values(example.data)
+         # Now get the mediation effects, by different approaches.
+         # 2. OLS estimate of second-stage
+         ols_firststage.reg <- lm(D ~ (1 + Z) + X_minus + X_IV, data = boot.data)
+         ols_secondstage.reg <- lm(Y ~ 1 + Z * D + X_minus, data = boot.data)
+         ols.est <- estimated.values(ols_firststage.reg, ols_secondstage.reg, boot.data)
+         # 3. Control Function estimates.
+         cf_firststage.reg <- lm(D ~ (1 + Z) * X_IV *
+             bs(X_minus, df = 20, intercept = TRUE),
+             data = boot.data)
+         boot.data$K <- cf_firststage.reg$fitted
+         boot.data$K_0 <- (1 - boot.data$D) * (1 - boot.data$K)
+         boot.data$K_1 <- boot.data$D * boot.data$K
+         cf_secondstage.reg <- lm(
+             Y ~ (1 + Z * D) + X_minus +
+             bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE) +
+             bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE),
+             #bs(K, knots = seq(-1, 1, by = 0.05), intercept = FALSE),
+             data = boot.data)
+         cf.est <- estimated.values(cf_firststage.reg, cf_secondstage.reg, boot.data)
+         # Save the outputs.
+         ols_direct_effect[i]   <- ols.est$`direct-effect`
+         ols_indirect_effect[i] <- ols.est$`indirect-effect`
+         cf_direct_effect[i]    <- cf.est$`direct-effect`
+         cf_indirect_effect[i]  <- cf.est$`indirect-effect`
+     }
+     # Return the bootstrap data.
+     output.list <- list()
+     output.list$data <- data.frame(
+         truth_direct_effect   = as.numeric(truth.est$average_direct_effect),
+         ols_direct_effect     = ols_direct_effect,
+         cf_direct_effect      = cf_direct_effect,
+         truth_indirect_effect = as.numeric(truth.est$average_indirect_effect),
+         ols_indirect_effect   = ols_indirect_effect,
+         cf_indirect_effect    = cf_indirect_effect
+     )
+     # Calculate the needed statistics, to return
+     output.list$estimates <- data.frame(
+         # Truth
+         truth_direct_effect     = as.numeric(truth.est$average_direct_effect),
+         truth_indirect_effect   = as.numeric(truth.est$average_indirect_effect),
+         # OLS mean, and the 95% confidence intervals
+         ols_direct_effect       = as.numeric(mean(ols_direct_effect)),
+         ols_direct_effect_se    = as.numeric(sd(ols_direct_effect)),
+         ols_direct_effect_up    = as.numeric(quantile(ols_direct_effect, probs = 0.975)),
+         ols_direct_effect_low   = as.numeric(quantile(ols_direct_effect, probs = 0.025)),
+         ols_indirect_effect     = as.numeric(mean(ols_indirect_effect)),
+         ols_indirect_effect_se  = as.numeric(sd(ols_indirect_effect)),
+         ols_indirect_effect_up  = as.numeric(quantile(ols_indirect_effect, probs = 0.975)),
+         ols_indirect_effect_low = as.numeric(quantile(ols_indirect_effect, probs = 0.025)),
+         # Control Fun mean, and the 95% confidence intervals
+         cf_direct_effect        = as.numeric(mean(cf_direct_effect)),
+         cf_direct_effect_se     = as.numeric(sd(cf_direct_effect)),
+         cf_direct_effect_up     = as.numeric(quantile(cf_direct_effect, probs = 0.975)),
+         cf_direct_effect_low    = as.numeric(quantile(cf_direct_effect, probs = 0.025)),
+         cf_indirect_effect      = as.numeric(mean(cf_indirect_effect)),
+         cf_indirect_effect_se   = as.numeric(sd(cf_indirect_effect)),
+         cf_indirect_effect_up   = as.numeric(quantile(cf_indirect_effect, probs = 0.975)),
+         cf_indirect_effect_low  = as.numeric(quantile(cf_indirect_effect, probs = 0.025))
+     )
+     return(output.list)
+ }
> 
> 
> ################################################################################
> ## Compare estimation methods, in one simulation.
> 
> ## Simulate the data: rho, sigma_0, sigma_1, sigma_C = 0.5, 1, 2, 1.
> simulated.data <- simulate.data(0.5, 1, 2, 0.25)
> # SHow the theoretical direct + indirect values
> print(theoretical.values(simulated.data, print.truth = TRUE))
[1] "Here is a summary of the (unobserved) true effects:"
[1] "How many compliers in the system?"
   D_0
D_1      0      1
  0 0.2351 0.0000
  1 0.6560 0.1089
[1] "The average total effect:" "2.58556289200545"         
[1] "The average first-stage:" "0.656"                   
[1] "The average direct effect:" "1.4331"                    
[1] "The average indirect effect:" "1.14486289200545"            
$average_first_stage
[1] 0.656

$average_total_effect
[1] 2.585563

$average_direct_effect
[1] 1.4331

$average_indirect_effect
[1] 1.144863

> 
> # Show that the regression specification holds exactly (after debiasing outcome).
> true_firststage.reg <- glm(D ~ (1 + Z) + X_IV +
+     bs(X_minus, df = 5, intercept = TRUE),
+     family = binomial(link = "probit"), data = simulated.data)
> simulated.data$K_0 <- (1 - simulated.data$D) * simulated.data$U_0
> simulated.data$K_1 <- simulated.data$D * simulated.data$U_1
> true_secondstage.reg <- lm(Y ~ (1 + Z * D) + X_minus +
+     # including the unobserved errors: U_0 - (D : U_0) + (D : U_1),
+     K_0 + K_1,
+     data = simulated.data)
> print(theoretical.values(simulated.data))
$average_first_stage
[1] 0.656

$average_total_effect
[1] 2.585563

$average_direct_effect
[1] 1.4331

$average_indirect_effect
[1] 1.144863

> print(estimated.values(true_firststage.reg, true_secondstage.reg, simulated.data))
$`first-stage`
[1] 0.6489042

$`direct-effect`
[1] 1.4331

$`indirect-effect`
[1] 1.111122

> print(summary(true_secondstage.reg))

Call:
lm(formula = Y ~ (1 + Z * D) + X_minus + K_0 + K_1, data = simulated.data)

Residuals:
       Min         1Q     Median         3Q        Max 
-4.875e-13 -1.500e-15 -6.000e-16 -3.000e-16  7.636e-12 

Coefficients:
             Estimate Std. Error   t value Pr(>|t|)    
(Intercept) 2.181e-14  3.767e-15 5.791e+00 7.19e-09 ***
Z           1.000e+00  2.650e-15 3.773e+14  < 2e-16 ***
D           1.000e+00  4.192e-15 2.386e+14  < 2e-16 ***
X_minus     1.000e+00  8.660e-16 1.155e+15  < 2e-16 ***
K_0         1.000e+00  1.057e-15 9.456e+14  < 2e-16 ***
K_1         1.000e+00  7.122e-16 1.404e+15  < 2e-16 ***
Z:D         1.000e+00  4.727e-15 2.116e+14  < 2e-16 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 8.037e-14 on 9993 degrees of freedom
Multiple R-squared:      1,	Adjusted R-squared:      1 
F-statistic: 1.344e+30 on 6 and 9993 DF,  p-value: < 2.2e-16

> 
> # Show how the OLS result gives a bias result (if rho != 0)
> ols_firststage.reg <- lm(D ~ (1 + Z) + X_minus + X_IV, data = simulated.data)
> ols_secondstage.reg <- lm(Y ~ 1 + Z * D + X_minus, data = simulated.data)
> print(theoretical.values(simulated.data))
$average_first_stage
[1] 0.656

$average_total_effect
[1] 2.585563

$average_direct_effect
[1] 1.4331

$average_indirect_effect
[1] 1.144863

> print(estimated.values(ols_firststage.reg, ols_secondstage.reg, simulated.data))
$`first-stage`
[1] 0.6489311

$`direct-effect`
[1] 0.5115903

$`indirect-effect`
[1] 2.038032

> 
> # Show how (unknown) control function gets it correct, in 2 steps (with splines)
> # -> Use the estimated CDF as the control function (as in Imbens Newey 2009).
> cf_firststage.reg <- lm(D ~ (1 + Z) * X_IV *
+     bs(X_minus, df = 20, intercept = TRUE),
+     data = simulated.data)
> simulated.data$K <- cf_firststage.reg$residuals
> simulated.data$K_0 <- (1 - simulated.data$D) * simulated.data$K
> simulated.data$K_1 <- simulated.data$D * simulated.data$K
> cf_secondstage.reg <- lm(Y ~ (1 + Z * D) + X_minus +
+     bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE) +
+     bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE),
+     #bs(K, knots = seq(0, 1, by = 0.025), intercept = TRUE),
+     data = simulated.data)
> print(summary(cf_secondstage.reg))

Call:
lm(formula = Y ~ (1 + Z * D) + X_minus + bs(K_0, knots = seq(0, 
    1, by = 0.05), intercept = FALSE) + bs(K_1, knots = seq(0, 
    1, by = 0.05), intercept = FALSE), data = simulated.data)

Residuals:
    Min      1Q  Median      3Q     Max 
-5.1953 -0.8507 -0.0150  0.8177  7.6329 

Coefficients: (19 not defined because of singularities)
                                                           Estimate Std. Error
(Intercept)                                                 0.57182    1.32807
Z                                                           0.76390    0.12976
D                                                           1.38454    0.25930
X_minus                                                     1.03544    0.02767
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)1  -0.34439    0.38805
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)2  -0.22181    0.19293
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)3  -0.55366    0.26351
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)4  -9.19122   18.86954
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)5  35.75705   80.46113
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)6        NA         NA
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)7  -1.32624    1.35139
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)8        NA         NA
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)9        NA         NA
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)10       NA         NA
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)11       NA         NA
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)12       NA         NA
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)13       NA         NA
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)14       NA         NA
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)15       NA         NA
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)16       NA         NA
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)17       NA         NA
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)18       NA         NA
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)19       NA         NA
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)20       NA         NA
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)21       NA         NA
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)22       NA         NA
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)23       NA         NA
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)24       NA         NA
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)1   1.19066    2.69635
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)2  -0.43863    1.31910
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)3  -0.24408    1.32362
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)4  -0.08044    1.30127
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)5  -0.20677    1.31217
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)6   0.35641    1.30951
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)7  -0.11511    1.31749
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)8   0.59211    1.31257
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)9   0.43512    1.31909
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)10  0.73842    1.32617
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)11  0.59311    1.34304
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)12  1.36719    1.33292
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)13  0.18497    1.33308
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)14  1.43720    1.35745
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)15  1.77202    1.38013
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)16  1.45052    1.36585
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)17  1.79910    1.34434
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)18  1.58813    1.33585
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)19  2.68345    1.37853
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)20  2.27446    1.37985
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)21  3.06848    1.40197
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)22  2.93663    1.41252
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)23  4.47045    1.43698
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)24       NA         NA
Z:D                                                         1.07829    0.16170
                                                           t value Pr(>|t|)    
(Intercept)                                                  0.431  0.66679    
Z                                                            5.887 4.06e-09 ***
D                                                            5.339 9.53e-08 ***
X_minus                                                     37.416  < 2e-16 ***
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)1   -0.887  0.37483    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)2   -1.150  0.25031    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)3   -2.101  0.03565 *  
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)4   -0.487  0.62620    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)5    0.444  0.65676    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)6       NA       NA    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)7   -0.981  0.32643    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)8       NA       NA    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)9       NA       NA    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)10      NA       NA    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)11      NA       NA    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)12      NA       NA    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)13      NA       NA    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)14      NA       NA    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)15      NA       NA    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)16      NA       NA    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)17      NA       NA    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)18      NA       NA    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)19      NA       NA    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)20      NA       NA    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)21      NA       NA    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)22      NA       NA    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)23      NA       NA    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)24      NA       NA    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)1    0.442  0.65880    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)2   -0.333  0.73950    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)3   -0.184  0.85370    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)4   -0.062  0.95071    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)5   -0.158  0.87479    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)6    0.272  0.78549    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)7   -0.087  0.93038    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)8    0.451  0.65192    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)9    0.330  0.74151    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)10   0.557  0.57767    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)11   0.442  0.65877    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)12   1.026  0.30505    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)13   0.139  0.88965    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)14   1.059  0.28974    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)15   1.284  0.19919    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)16   1.062  0.28827    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)17   1.338  0.18084    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)18   1.189  0.23453    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)19   1.947  0.05161 .  
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)20   1.648  0.09931 .  
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)21   2.189  0.02864 *  
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)22   2.079  0.03764 *  
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)23   3.111  0.00187 ** 
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)24      NA       NA    
Z:D                                                          6.668 2.72e-11 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 1.336 on 9966 degrees of freedom
Multiple R-squared:  0.6583,	Adjusted R-squared:  0.6572 
F-statistic: 581.9 on 33 and 9966 DF,  p-value: < 2.2e-16

> print(theoretical.values(simulated.data))
$average_first_stage
[1] 0.656

$average_total_effect
[1] 2.585563

$average_direct_effect
[1] 1.4331

$average_indirect_effect
[1] 1.144863

> print(estimated.values(cf_firststage.reg, cf_secondstage.reg, simulated.data))
$`first-stage`
[1] 0.6491601

$`direct-effect`
[1] 1.230909

$`indirect-effect`
[1] 1.313183

> 
> #! Test: Imbens Newey (2009) conditional CDF as the control function.
> cf_firststage.reg <- lm(D ~ (1 + Z) * X_IV *
+     bs(X_minus, df = 20, intercept = TRUE),
+     data = simulated.data)
> simulated.data$K <- ifelse(simulated.data$D == 0,
+     1 - cf_firststage.reg$fitted, cf_firststage.reg$fitted)
> simulated.data$K_0 <- (1 - simulated.data$D) * simulated.data$K
> simulated.data$K_1 <- simulated.data$D * simulated.data$K
> cf_secondstage.reg <- lm(Y ~ (1 + Z * D) + X_minus +
+     bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE) +
+     bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE),
+     data = simulated.data)
> print(summary(cf_secondstage.reg))

Call:
lm(formula = Y ~ (1 + Z * D) + X_minus + bs(K_0, knots = seq(0, 
    1, by = 0.05), intercept = FALSE) + bs(K_1, knots = seq(0, 
    1, by = 0.05), intercept = FALSE), data = simulated.data)

Residuals:
    Min      1Q  Median      3Q     Max 
-5.1934 -0.8526 -0.0151  0.8180  7.6289 

Coefficients: (2 not defined because of singularities)
                                                           Estimate Std. Error
(Intercept)                                                -5.92499    2.12108
Z                                                           0.75184    0.13702
D                                                           4.02099    7.55661
X_minus                                                     1.04346    0.02946
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)1   3.34765    7.58550
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)2   0.47715    2.01386
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)3   1.75543    1.51355
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)4   0.18450    1.37435
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)5   1.13164    1.31523
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)6   0.52588    1.31991
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)7   1.02345    1.31824
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)8   0.56247    1.30523
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)9   0.98771    1.30673
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)10  0.44978    1.31985
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)11  0.98658    1.32714
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)12  0.44057    1.30767
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)13  0.71914    1.31039
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)14  0.60562    1.32151
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)15  0.89499    1.32394
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)16  0.40275    1.30472
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)17  0.74883    1.29735
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)18  0.51257    1.28860
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)19  0.43975    1.30032
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)20  0.48943    1.28046
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)21  0.48661    1.30193
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)22  0.54872    1.26950
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)23 -1.63675    2.20592
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)24       NA         NA
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)1   5.26616    1.69440
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)2   2.87806    1.47492
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)3   3.07799    1.41849
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)4   2.24973    1.38068
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)5   2.65868    1.37937
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)6   1.56417    1.33666
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)7   1.78561    1.34491
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)8   1.42809    1.36662
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)9   1.75891    1.38071
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)10  1.41736    1.35815
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)11  0.17346    1.33362
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)12  1.35540    1.33347
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)13  0.58023    1.34360
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)14  0.73273    1.32665
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)15  0.42412    1.31962
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)16  0.58777    1.31304
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)17 -0.12347    1.31799
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)18  0.35806    1.30997
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)19 -0.21116    1.31264
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)20 -0.07570    1.30174
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)21 -0.24332    1.32409
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)22 -0.40329    1.32031
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)23  1.17775    2.69734
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)24       NA         NA
Z:D                                                         1.06549    0.16381
                                                           t value Pr(>|t|)    
(Intercept)                                                 -2.793  0.00523 ** 
Z                                                            5.487 4.19e-08 ***
D                                                            0.532  0.59466    
X_minus                                                     35.415  < 2e-16 ***
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)1    0.441  0.65899    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)2    0.237  0.81271    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)3    1.160  0.24615    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)4    0.134  0.89321    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)5    0.860  0.38958    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)6    0.398  0.69033    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)7    0.776  0.43754    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)8    0.431  0.66652    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)9    0.756  0.44975    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)10   0.341  0.73327    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)11   0.743  0.45726    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)12   0.337  0.73619    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)13   0.549  0.58315    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)14   0.458  0.64676    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)15   0.676  0.49905    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)16   0.309  0.75757    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)17   0.577  0.56381    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)18   0.398  0.69080    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)19   0.338  0.73523    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)20   0.382  0.70230    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)21   0.374  0.70859    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)22   0.432  0.66558    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)23  -0.742  0.45811    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)24      NA       NA    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)1    3.108  0.00189 ** 
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)2    1.951  0.05104 .  
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)3    2.170  0.03004 *  
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)4    1.629  0.10325    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)5    1.927  0.05395 .  
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)6    1.170  0.24194    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)7    1.328  0.18432    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)8    1.045  0.29606    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)9    1.274  0.20272    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)10   1.044  0.29670    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)11   0.130  0.89652    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)12   1.016  0.30944    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)13   0.432  0.66586    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)14   0.552  0.58075    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)15   0.321  0.74792    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)16   0.448  0.65442    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)17  -0.094  0.92537    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)18   0.273  0.78460    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)19  -0.161  0.87220    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)20  -0.058  0.95363    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)21  -0.184  0.85420    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)22  -0.305  0.76003    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)23   0.437  0.66238    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)24      NA       NA    
Z:D                                                          6.504 8.18e-11 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 1.337 on 9949 degrees of freedom
Multiple R-squared:  0.6587,	Adjusted R-squared:  0.657 
F-statistic:   384 on 50 and 9949 DF,  p-value: < 2.2e-16

> print(theoretical.values(simulated.data))
$average_first_stage
[1] 0.656

$average_total_effect
[1] 2.585563

$average_direct_effect
[1] 1.4331

$average_indirect_effect
[1] 1.144863

> print(estimated.values(cf_firststage.reg, cf_secondstage.reg, simulated.data))
$`first-stage`
[1] 0.6491601

$`direct-effect`
[1] 1.213306

$`indirect-effect`
[1] 1.330915

> 
> 
> #! Test, add on the K_0 and K_1 conditional on D_i = 0,1 respectively in truth
> firststage.est <- predict(
+     true_firststage.reg, newdata = mutate(simulated.data, Z = 1), type = "response") - predict(
+         true_firststage.reg, newdata = mutate(simulated.data, Z = 0), type = "response")
> # calculate the second-stage indirect effect
> indirect.est <- predict(
+     true_secondstage.reg, newdata = mutate(simulated.data, D = 1)) -
+     predict(true_secondstage.reg, newdata = mutate(simulated.data, D = 0))
> add.term <- (mean(simulated.data$K_1[simulated.data$D_0 == 0 & simulated.data$D_1 == 1 & simulated.data$D == 1])
+     - mean(simulated.data$K_0[simulated.data$D_0 == 0 & simulated.data$D_1 == 1 & simulated.data$D == 0]))
> print(mean(firststage.est * (indirect.est + add.term)))
[1] 0.9055664
> #! Do the same thing, but kappa weighted to the compliers inside the CF estimate.
> firststage.est <- predict(
+     cf_firststage.reg, newdata = mutate(simulated.data, Z = 1), type = "response") - predict(
+         cf_firststage.reg, newdata = mutate(simulated.data, Z = 0), type = "response")
> # calculate the second-stage indirect effect
> indirect.est <- predict(
+     cf_secondstage.reg, newdata = mutate(simulated.data, D = 1)) -
+     predict(cf_secondstage.reg, newdata = mutate(simulated.data, D = 0))
> # Estimate the kappa-weight
> hat_probZ <- 0.5
> kappa_1 <- simulated.data$D * ((simulated.data$Z - hat_probZ) / (
+     (1 - hat_probZ) * hat_probZ))
> kappa_0 <- (1 - simulated.data$D) * (((1 - simulated.data$Z) - (1 - hat_probZ)) / (
+     (1 - hat_probZ) * hat_probZ))
> kappa.weight <- kappa_1 * hat_probZ + kappa_0 * (1 - hat_probZ)
> # Calculate the term to add on.
> add.term <- (weighted.mean(simulated.data$K_1[simulated.data$D == 1],
+         kappa.weight[simulated.data$D == 1])
+     - weighted.mean(simulated.data$K_0[simulated.data$D == 0],
+         kappa.weight[simulated.data$D == 0]))
> add.term <- (weighted.mean(simulated.data$K, kappa.weight))
> mean(firststage.est * (indirect.est + add.term))
[1] 3.604344
> 
> #! Test: show the ADE given Z_i = 1, and similar for AIE
> firststage.est <- predict(
+     true_firststage.reg, newdata = mutate(simulated.data, Z = 1), type = "response") - predict(
+         true_firststage.reg, newdata = mutate(simulated.data, Z = 0), type = "response")
> # calculate the second-stage direct effect
> direct.est <- predict(
+     true_secondstage.reg, newdata = mutate(simulated.data, Z = 1)) -
+     predict(true_secondstage.reg, newdata = mutate(simulated.data, Z = 0))
> # calculate the second-stage indirect effect
> indirect.est <- predict(
+     true_secondstage.reg, newdata = mutate(simulated.data, D = 1)) -
+     predict(true_secondstage.reg, newdata = mutate(simulated.data, D = 0))
> # Return the mean estimates.
> print(theoretical.values(simulated.data))
$average_first_stage
[1] 0.656

$average_total_effect
[1] 2.585563

$average_direct_effect
[1] 1.4331

$average_indirect_effect
[1] 1.144863

> print(c("first-stage",     mean(firststage.est)))
[1] "first-stage"      "0.64890418747204"
> print(c("direct-effect",   mean(direct.est)))
[1] "direct-effect"    "1.43309999999983"
> print(c("indirect-effect", mean(firststage.est * indirect.est)))
[1] "indirect-effect"   "0.972744117244759"
> # Get the treated versions
> Z <- simulated.data$Z
> D <- simulated.data$D
> Y <- simulated.data$Y
> D_0 <- simulated.data$D_0
> D_1 <- simulated.data$D_1
> Y_0_0 <- simulated.data$Y_0_0
> Y_0_1 <- simulated.data$Y_0_1
> Y_1_0 <- simulated.data$Y_1_0
> Y_1_1 <- simulated.data$Y_1_1
> # AIE, estimae vs the group differences term.
> print(c("indirect-effect", mean(firststage.est * indirect.est)))
[1] "indirect-effect"   "0.972744117244759"
> indirect_effect <- (Z * (Y_1_1 - Y_1_0) + (1 - Z) * (Y_0_1 - Y_0_0))
> print(mean(indirect_effect * (D_1 != D_0)))
[1] 1.144863
> print(mean(indirect_effect * mean(D_1 != D_0)))
[1] 0.9747298
> print(estimated.values(true_firststage.reg, true_secondstage.reg, simulated.data)$`indirect-effect`)
[1] 0.8385013
> 
> # ADE, estimate vs group differences term.
> print(c("direct-effect",   mean(direct.est)))
[1] "direct-effect"    "1.43309999999983"
> direct_effect <- (D * (Y_1_1 - Y_0_1) + (1 - D) * (Y_1_0 - Y_0_0))
> print(mean(direct_effect))
[1] 1.4331
> print(mean(direct_effect[Z == 1]))
[1] 1.759478
> 
> #! Test: note the difference between AIE and LAIE (i.e., group differences term).
> # show gains to D, on average
> print(mean(simulated.data$Z * (simulated.data$Y_1_1 - simulated.data$Y_1_0) +
+     (1 - simulated.data$Z) * (simulated.data$Y_0_1 - simulated.data$Y_0_0)))
[1] 1.485869
> # show gains to D, among compliers
> print(mean((simulated.data$Z * (simulated.data$Y_1_1 - simulated.data$Y_1_0) +
+     (1 - simulated.data$Z) * (simulated.data$Y_0_1 - simulated.data$Y_0_0)) * (
+         simulated.data$D_1 == 1 & simulated.data$D_0 == 0)))
[1] 1.144863
> 
> #! Test, get compliers correct
> #! -> needs a different weighting scheme
> #! -> Abadie (2003) kappa weights do not get it correct.
> library(mgcv)
Loading required package: nlme

Attaching package: ‘nlme’

The following object is masked from ‘package:dplyr’:

    collapse

This is mgcv 1.9-1. For overview type 'help("mgcv-package")'.
> cf_firststage.reg <- lm(D ~ (1 + Z) * X_IV * bs(X_minus, df = 20, intercept = TRUE),
+     data = simulated.data)
> complier.weights <- predict(
+     cf_firststage.reg, newdata = mutate(simulated.data, Z = 1), type = "response") - predict(
+         cf_firststage.reg, newdata = mutate(simulated.data, Z = 0), type = "response")
> complier.weights[complier.weights < 0] <- 0
> complier_secondstage.reg <- lm(Y ~ (1 + Z * D) + X_minus +
+     bs(K, knots = seq(-1, 1, by = 0.05)),
+     weights = complier.weights,
+     data = simulated.data)
> print(theoretical.values(simulated.data))
$average_first_stage
[1] 0.656

$average_total_effect
[1] 2.585563

$average_direct_effect
[1] 1.4331

$average_indirect_effect
[1] 1.144863

> print(estimated.values(cf_firststage.reg, complier_secondstage.reg, simulated.data))
$`first-stage`
[1] 0.6491601

$`direct-effect`
[1] 0.3909452

$`indirect-effect`
[1] 1.805192

> 
> #! Test: including the K_0 and K_1 terms in complier gains
> simulated.data$K_0 <- (1 - simulated.data$D) * (1 - cf_firststage.reg$residuals)
> simulated.data$K_1 <- simulated.data$D * cf_firststage.reg$residuals
> complier_secondstage.reg <- lm(Y ~ (1 + Z * D) + X_minus +
+     bs(K_0, knots = seq(-0.05, 1.05, by = 0.05)) +
+     bs(K_1, knots = seq(-0.05, 1.05, by = 0.05)),
+     data = simulated.data)
> 
> # Get the returns estimate correct.
> print(mean((simulated.data$Y_0_1 - simulated.data$Y_0_0)[
+         simulated.data$Z == 0]))
[1] 1.005757
> print(mean((simulated.data$Y_0_1 - simulated.data$Y_0_0)[
+         simulated.data$Z == 0 & simulated.data$D_1 == 1 & simulated.data$D_0 == 0]))
[1] 1.272958
> print(mean((predict(
+     cf_firststage.reg, newdata = mutate(simulated.data, Z = 1), type = "response") - predict(
+         cf_firststage.reg, newdata = mutate(simulated.data, Z = 0), type = "response")) * (
+     predict(complier_secondstage.reg,
+         newdata = mutate(simulated.data, Z = 0, D = 1, K_0 = 0, K_1 = K_1)) -
+     predict(complier_secondstage.reg,
+         newdata = mutate(simulated.data, Z = 0, D = 0, K_0 = K_0, K_1 = 0)))))
[1] 0.9472293
Warning message:
In predict.lm(complier_secondstage.reg, newdata = mutate(simulated.data,  :
  prediction from rank-deficient fit; attr(*, "non-estim") has doubtful cases
> print(mean(predict(complier_secondstage.reg,
+         newdata = mutate(simulated.data, Z = 0, D = 1, K_0 = 0, K_1 = 0)) -
+     predict(complier_secondstage.reg,
+         newdata = mutate(simulated.data, Z = 0, D = 0, K_0 = 0, K_1 = 0))))
[1] 1.038954
Warning message:
In predict.lm(complier_secondstage.reg, newdata = mutate(simulated.data,  :
  prediction from rank-deficient fit; attr(*, "non-estim") has doubtful cases
> 
> # calculate the second-stage indirect effect
> firststage.est <- predict(
+     cf_firststage.reg, newdata = mutate(simulated.data, Z = 1), type = "response") - predict(
+         cf_firststage.reg, newdata = mutate(simulated.data, Z = 0), type = "response")
> indirect.est <- predict(
+     complier_secondstage.reg, newdata = mutate(simulated.data, D = 1, K_0 = 0)) -
+         predict(complier_secondstage.reg, newdata = mutate(simulated.data, D = 0, K_1 = 0))
Warning message:
In predict.lm(complier_secondstage.reg, newdata = mutate(simulated.data,  :
  prediction from rank-deficient fit; attr(*, "non-estim") has doubtful cases
> direct.est <- predict(
+     complier_secondstage.reg, newdata = mutate(simulated.data, Z = 1)) -
+         predict(complier_secondstage.reg, newdata = mutate(simulated.data, Z = 0))
> # Show the means
> print(theoretical.values(simulated.data))
$average_first_stage
[1] 0.656

$average_total_effect
[1] 2.585563

$average_direct_effect
[1] 1.4331

$average_indirect_effect
[1] 1.144863

> print(mean(direct.est))
[1] 1.181134
> print(mean(firststage.est * indirect.est))
[1] 1.297626
> # Compared the un-weighted version (which has group differences bias).
> print(estimated.values(cf_firststage.reg, complier_secondstage.reg, simulated.data))
$`first-stage`
[1] 0.6491601

$`direct-effect`
[1] 1.181134

$`indirect-effect`
[1] 1.36305

Warning messages:
1: In predict.lm(secondstage.reg, newdata = mutate(example.data, D = 1)) :
  prediction from rank-deficient fit; attr(*, "non-estim") has doubtful cases
2: In predict.lm(secondstage.reg, newdata = mutate(example.data, D = 0)) :
  prediction from rank-deficient fit; attr(*, "non-estim") has doubtful cases
3: In predict.lm(secondstage.reg, newdata = mutate(filter(example.data,  :
  prediction from rank-deficient fit; attr(*, "non-estim") has doubtful cases
> print(estimated.values(cf_firststage.reg, cf_secondstage.reg, simulated.data))
$`first-stage`
[1] 0.6491601

$`direct-effect`
[1] 1.213306

$`indirect-effect`
[1] 194.8512

Warning messages:
1: In bs(K_0, degree = 3L, knots = c(0, 0.05, 0.1, 0.15, 0.2, 0.25,  :
  some 'x' values beyond boundary knots may cause ill-conditioned bases
2: In bs(K_1, degree = 3L, knots = c(0, 0.05, 0.1, 0.15, 0.2, 0.25,  :
  some 'x' values beyond boundary knots may cause ill-conditioned bases
3: In bs(K_0, degree = 3L, knots = c(0, 0.05, 0.1, 0.15, 0.2, 0.25,  :
  some 'x' values beyond boundary knots may cause ill-conditioned bases
4: In bs(K_1, degree = 3L, knots = c(0, 0.05, 0.1, 0.15, 0.2, 0.25,  :
  some 'x' values beyond boundary knots may cause ill-conditioned bases
5: In bs(K_0, degree = 3L, knots = c(0, 0.05, 0.1, 0.15, 0.2, 0.25,  :
  some 'x' values beyond boundary knots may cause ill-conditioned bases
6: In bs(K_1, degree = 3L, knots = c(0, 0.05, 0.1, 0.15, 0.2, 0.25,  :
  some 'x' values beyond boundary knots may cause ill-conditioned bases
7: In bs(K_0, degree = 3L, knots = c(0, 0.05, 0.1, 0.15, 0.2, 0.25,  :
  some 'x' values beyond boundary knots may cause ill-conditioned bases
8: In bs(K_1, degree = 3L, knots = c(0, 0.05, 0.1, 0.15, 0.2, 0.25,  :
  some 'x' values beyond boundary knots may cause ill-conditioned bases
9: In bs(K_1, degree = 3L, knots = c(0, 0.05, 0.1, 0.15, 0.2, 0.25,  :
  some 'x' values beyond boundary knots may cause ill-conditioned bases
10: In bs(K_0, degree = 3L, knots = c(0, 0.05, 0.1, 0.15, 0.2, 0.25,  :
  some 'x' values beyond boundary knots may cause ill-conditioned bases
> 
> 
> ################################################################################
> ## Plot bootstrap results for one DGP
> 
> # Base data to test out.
> simulated.data <- simulate.data(0.5, 1, 2, 0.25)
> 
> # Get bootstrapped point est for the CF approach
> boot.reps <- 10^2
> boot.est <- estimated.loop(boot.reps, simulated.data, bootstrap = FALSE)
[1] "1 out of 100, 1% done."
[1] "2 out of 100, 2% done."
[1] "3 out of 100, 3% done."
[1] "4 out of 100, 4% done."
[1] "5 out of 100, 5% done."
[1] "6 out of 100, 6% done."
[1] "8 out of 100, 8% done."
[1] "9 out of 100, 9% done."
[1] "10 out of 100, 10% done."
[1] "11 out of 100, 11% done."
[1] "12 out of 100, 12% done."
[1] "13 out of 100, 13% done."
[1] "15 out of 100, 15% done."
[1] "16 out of 100, 16% done."
[1] "17 out of 100, 17% done."
[1] "18 out of 100, 18% done."
[1] "19 out of 100, 19% done."
[1] "20 out of 100, 20% done."
[1] "21 out of 100, 21% done."
[1] "22 out of 100, 22% done."
[1] "23 out of 100, 23% done."
[1] "24 out of 100, 24% done."
[1] "25 out of 100, 25% done."
[1] "26 out of 100, 26% done."
[1] "27 out of 100, 27% done."
[1] "30 out of 100, 30% done."
[1] "31 out of 100, 31% done."
[1] "32 out of 100, 32% done."
[1] "33 out of 100, 33% done."
[1] "34 out of 100, 34% done."
[1] "35 out of 100, 35% done."
[1] "36 out of 100, 36% done."
[1] "37 out of 100, 37% done."
[1] "38 out of 100, 38% done."
[1] "39 out of 100, 39% done."
[1] "40 out of 100, 40% done."
[1] "41 out of 100, 41% done."
[1] "42 out of 100, 42% done."
[1] "43 out of 100, 43% done."
[1] "44 out of 100, 44% done."
[1] "45 out of 100, 45% done."
[1] "46 out of 100, 46% done."
[1] "47 out of 100, 47% done."
[1] "48 out of 100, 48% done."
[1] "49 out of 100, 49% done."
[1] "50 out of 100, 50% done."
[1] "51 out of 100, 51% done."
[1] "52 out of 100, 52% done."
[1] "53 out of 100, 53% done."
[1] "54 out of 100, 54% done."
[1] "59 out of 100, 59% done."
[1] "60 out of 100, 60% done."
[1] "61 out of 100, 61% done."
[1] "62 out of 100, 62% done."
[1] "63 out of 100, 63% done."
[1] "64 out of 100, 64% done."
[1] "65 out of 100, 65% done."
[1] "66 out of 100, 66% done."
[1] "67 out of 100, 67% done."
[1] "68 out of 100, 68% done."
[1] "69 out of 100, 69% done."
[1] "70 out of 100, 70% done."
[1] "71 out of 100, 71% done."
[1] "72 out of 100, 72% done."
[1] "73 out of 100, 73% done."
[1] "74 out of 100, 74% done."
[1] "75 out of 100, 75% done."
[1] "76 out of 100, 76% done."
[1] "77 out of 100, 77% done."
[1] "78 out of 100, 78% done."
[1] "79 out of 100, 79% done."
[1] "80 out of 100, 80% done."
[1] "81 out of 100, 81% done."
[1] "82 out of 100, 82% done."
[1] "83 out of 100, 83% done."
[1] "84 out of 100, 84% done."
[1] "85 out of 100, 85% done."
[1] "86 out of 100, 86% done."
[1] "87 out of 100, 87% done."
[1] "88 out of 100, 88% done."
[1] "89 out of 100, 89% done."
[1] "90 out of 100, 90% done."
[1] "91 out of 100, 91% done."
[1] "92 out of 100, 92% done."
[1] "93 out of 100, 93% done."
[1] "94 out of 100, 94% done."
[1] "95 out of 100, 95% done."
[1] "96 out of 100, 96% done."
[1] "97 out of 100, 97% done."
[1] "98 out of 100, 98% done."
[1] "99 out of 100, 99% done."
[1] "100 out of 100, 100% done."
> boot.data <- boot.est$data
> 
> ## Save the bootstrapped point estimates data.
> boot.data %>% write_csv(file.path(output.folder, "boot-sim-data-test.csv"))
> exit.
Error: object 'exit.' not found
Execution halted
