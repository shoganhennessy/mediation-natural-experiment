
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> #!/usr/bin/R
> ## Senan Hogan-Hennessy, 16 Jan 2025
> ## Simulate the system for indirect + direct effects, with Roy selection.
> # Show the date:
> print(format(Sys.time(), "%H:%M %Z %A, %d %B %Y"))
[1] "11:30 EST Saturday, 25 January 2025"
> 
> ## Load libraries
> # Functions for data manipulation and visualisation
> library(tidyverse)
── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──
✔ dplyr     1.1.4     ✔ readr     2.1.5
✔ forcats   1.0.0     ✔ stringr   1.5.1
✔ ggplot2   3.5.1     ✔ tibble    3.2.1
✔ lubridate 1.9.3     ✔ tidyr     1.3.1
✔ purrr     1.0.2     
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors
> # Library for better colour choice.
> library(ggthemes)
> # Library for equations in plots
> library(latex2exp)
> # Causal medation package, Imai Keele Yamamoto (2010)
> library(mediation)
Loading required package: MASS

Attaching package: ‘MASS’

The following object is masked from ‘package:dplyr’:

    select

Loading required package: Matrix

Attaching package: ‘Matrix’

The following objects are masked from ‘package:tidyr’:

    expand, pack, unpack

Loading required package: mvtnorm
Loading required package: sandwich
mediation: Causal Mediation Analysis
Version: 4.5.0

> # Package for classical selection estimators (i.e., MLE)
> library(sampleSelection)
Loading required package: maxLik
Loading required package: miscTools

Please cite the 'maxLik' package as:
Henningsen, Arne and Toomet, Ott (2011). maxLik: A package for maximum likelihood estimation in R. Computational Statistics 26(3), 443-458. DOI 10.1007/s00180-010-0217-1.

If you have questions, suggestions, or comments regarding the 'maxLik' package, please use a forum or 'tracker' at maxLik's R-Forge site:
https://r-forge.r-project.org/projects/maxlik/
> # Package for semi-parametric regressor
> library(splines)
> library(mgcv)
Loading required package: nlme

Attaching package: ‘nlme’

The following object is masked from ‘package:dplyr’:

    collapse

This is mgcv 1.9-1. For overview type 'help("mgcv-package")'.
> 
> ## Set up the R environment
> set.seed(47)
> # Define number of digits in tables and graphs
> digits.no <- 3
> # Define where output files go.
> output.folder <- file.path("sim-output")
> # Set the options for the plot sizes, in saving ggplot output.
> fig.height <- 10
> fig.width <- fig.height
> 
> # Define the sample size to work with.
> sample.N <- 10^4
> 
> 
> ################################################################################
> ## Define a function to simulate data in the triangular system.
> 
> # Define a function to simulate all observed + unobserved data 
> simulate.data <- function(rho, sigma_0, sigma_1, sigma_C,
+         sample.size = sample.N){
+     ### Inputs:
+     ## X, a matrix of covariates, continuous or binary values.
+     ## rho \in [-1, +1] measuring correlation between U_0, U_1.
+     ## sigma_0 >= 0 measuring standard deviation of U_0.
+     ## sigma_1 >= 0 measuring standard deviation of U_1.
+     ## sigma_C >= 0 measuring standard deviation of U_C.
+     ## sample.size: integer, representing output sample size i.e., N.
+     # First covariate (\vec X_i^-)
+     X_minus <- 4 + rnorm(sample.size, mean = 0, sd = 1)
+     # Second covariate (instrument for the control fun).
+     X_IV <- rbinom(sample.size, 1, 1 / 2)
+     # Simulate the unobserved error terms.
+     U_both <- MASS::mvrnorm(
+         n = sample.size,
+         mu = c(0, 0, 0),
+         Sigma = matrix(c(
+             sigma_0^2,                rho * sigma_0 * sigma_1,  0,
+             rho * sigma_0 * sigma_1,  sigma_1^2,                0,
+             0,                        0,                        sigma_C^2), ncol = 3),
+         empirical = FALSE)
+     U_0 <- U_both[, 1]
+     U_1 <- U_both[, 2]
+     U_C <- U_both[, 3]
+     # Define the mean potential outcomes.
+     mu_outcome_d_z_X <- function(d, z, x_minus){
+         return(x_minus + (z + d + z * d))
+     }
+     mu_cost_z_X <- function(z, x_minus, x_iv){
+         return(- 3 * z + x_minus - x_iv)
+     }
+     # Y_i(Z, D) = mu_D(Z; X_i) + U_D
+     Y_0_0 <- mu_outcome_d_z_X(0, 0, X_minus) + U_0
+     Y_0_1 <- mu_outcome_d_z_X(1, 0, X_minus) + U_1
+     Y_1_0 <- mu_outcome_d_z_X(0, 1, X_minus) + U_0
+     Y_1_1 <- mu_outcome_d_z_X(1, 1, X_minus) + U_1
+     # D_i(Z)= 1{ Y(Z, 1) - Y(Z, 0) >= C_i }
+     D_0 <- as.integer(Y_0_1 - Y_0_0 >= mu_cost_z_X(0, X_minus, X_IV) + U_C)
+     D_1 <- as.integer(Y_1_1 - Y_1_0 >= mu_cost_z_X(1, X_minus, X_IV) + U_C)
+     # Generate the individual effects (direct + indirect)
+     probZ <- 0.5
+     Z <- rbinom(sample.size, 1, probZ)
+     # Observed outcomes: D, Y
+     D <- (Z * D_1) + ((1 - Z) * D_0)
+     # Generate the list of observed outcomes
+     Y <- (Z * D * Y_1_1) +
+         (Z * (1 - D) * Y_1_0) +
+         ((1 - Z) * D * Y_0_1) +
+         ((1 - Z) * (1 - D) * Y_0_0)
+     # Put these data to a coherent data frame.
+     combined.data <- tibble(data.frame(
+         # Observed data
+         Z, D, Y,  X_minus, X_IV,
+         # Unobserved, potential outcomes and compliance.
+         D_0, D_1,
+         Y_0_0, Y_0_1, Y_1_0, Y_1_1,
+         #mu0_Z0_X, mu1_Z0_X, mu0_Z1_X, mu1_Z1_X, muC_Z0_X, muC_Z1_X, 
+         U_0, U_1, U_C))
+     # Return the simulated data as a data frame.
+     return(combined.data)
+ }
> 
> 
> ################################################################################
> ## Define a function to show the theoretical values for the data.
> theoretical.values <- function(sim.data, digits.no = 3){
+     ### Inputs:
+     ## sim.data, a data frame simulated from above.
+     # Extract the potentials from simulated data.
+     Z <- sim.data$Z
+     D <- sim.data$D
+     Y <- sim.data$Y
+     X_minus <- sim.data$X_minus
+     X_IV <- sim.data$X_IV
+     D_0 <- sim.data$D_0
+     D_1 <- sim.data$D_1
+     Y_0_0 <- sim.data$Y_0_0
+     Y_0_1 <- sim.data$Y_0_1
+     Y_1_0 <- sim.data$Y_1_0
+     Y_1_1 <- sim.data$Y_1_1
+     U_0 <- sim.data$U_0
+     U_1 <- sim.data$U_1
+     U_C <- sim.data$U_C
+     # Get the true first-stage effects
+     first_stage <- D_1 - D_0
+     average_first_stage <- mean(first_stage)
+     # Show how many ATs, NTs, Compliers in terms of D_i(Z) for Z = 0, 1.
+     # print("How many compliers in the sample?")
+     # print(table(D_1, D_0) / sample.size)
+     # Get the theoretical total effect/reduced form/ITT
+     total_effect <-
+         (Y_1_1 - Y_0_0) * (D_1 == 1 & D_0 == 0) +
+         (Y_1_1 - Y_0_1) * (D_1 == 1 & D_0 == 1) +
+         (Y_1_0 - Y_0_0) * (D_1 == 0 & D_0 == 0)
+     average_total_effect <- mean(total_effect)
+     # Get the theoretical indirect effect.
+     indirect_effect <-
+         (Z * (Y_1_1 - Y_1_0) + (1 - Z) * (Y_0_1 - Y_0_0)) * (D_1 != D_0)
+     average_indirect_effect <- mean(indirect_effect)
+     # Get the theoretical direct effect.
+     direct_effect <-
+         (D * (Y_1_1 - Y_0_1) + (1 - D) * (Y_1_0 - Y_0_0)) * (D_1 == 1 & D_0 == 0) +
+         (Y_1_1 - Y_0_1) * (D_1 == 1 & D_0 == 1) +
+         (Y_1_0 - Y_0_0) * (D_1 == 0 & D_0 == 0)
+     average_direct_effect <- mean(direct_effect)
+     # Define a named list to return
+     output.list <- list(
+         average_first_stage     = average_first_stage,
+         #average_total_effect    = average_total_effect,,
+         average_direct_effect   = average_direct_effect,
+         average_indirect_effect = average_indirect_effect)
+     # Return the output.list
+     return(output.list)
+ }
> 
> ################################################################################
> ## Define a function to estimate mediation, given the first + second-stages.
> 
> # Estimate the values, given a first and second-stages
> estimated.values <- function(firststage.reg, secondstage.reg, example.data){
+     ### Inputs:
+     ## example.data, a data frame simulated from above.
+     # calculate the first-stage by prediction
+     firststage.est <- predict(
+         firststage.reg, newdata = mutate(example.data, Z = 1), type = "response") - predict(
+             firststage.reg, newdata = mutate(example.data, Z = 0), type = "response")
+     # calculate the second-stage direct effect
+     direct.est <- predict(
+         secondstage.reg, newdata = mutate(example.data, Z = 1)) -
+         predict(secondstage.reg, newdata = mutate(example.data, Z = 0))
+     # calculate the second-stage indirect effect
+     indirect.est <- predict(
+         secondstage.reg, newdata = mutate(example.data, D = 1)) -
+         predict(secondstage.reg, newdata = mutate(example.data, D = 0))
+     # Return the mean estimates.
+     output.list <- list(
+         "first-stage"     = mean(firststage.est),
+         "direct-effect"   = mean(direct.est),
+         "indirect-effect" = mean(firststage.est * indirect.est))
+     # Return the output.list
+ }
> 
> # Bootstrap the estimates.
> estimated.bootstrap <- function(boot.reps, example.data,
+         sample.size = sample.N, print.progress = TRUE){
+     # Define lists the will be returned:
+     # 2. Naive OLS.
+     ols_direct_effect <- c()
+     ols_indirect_effect <- c()
+     # 3. Control function.
+     cf_direct_effect <- c()
+     cf_indirect_effect <- c()
+     # More in the future ....
+     # Calculate the truth values, given the simulated data
+     truth.est <- theoretical.values(example.data)
+     # Loop across the bootstraps values.
+     for (i in seq(1, boot.reps)){
+         # Print on whole percentage values
+         if (print.progress & ((100 * (i / boot.reps)) %% 1) == 0) {
+             print(paste0(i, " out of ", boot.reps, ", ", 100 * (i / boot.reps), "% done."))
+         }
+         # Draw a bootstrap sample from data
+         boot.indicies <- sample(seq(1, sample.size), sample.size, replace = TRUE)
+         boot.data <- example.data[boot.indicies, ]
+         # Now get the mediation effects, by different approaches.
+         # 2. OLS estimate of second-stage
+         ols_firststage.reg <- lm(D ~ (1 + Z) + X_minus + X_IV, data = boot.data)
+         ols_secondstage.reg <- lm(Y ~ 1 + D + Z + Z:D + X_minus, data = boot.data)
+         ols.est <- estimated.values(ols_firststage.reg, ols_secondstage.reg, boot.data)
+         # 3. Control Function estimates.
+         #cf_firststage.reg <- gam(D ~ (1 + Z) * X_IV +
+         #    s(X_minus, bs = "cr", k = 20),
+         #    #family = binomial(link = "probit"),
+         #    data = boot.data)
+         #boot.data$K <- cf_firststage.reg$residuals
+         #cf_secondstage.reg <- gam(Y ~ (1 + Z * D) + X_minus +
+         #    s(K, bs = "cr", k = 20),
+         #    data = boot.data)
+         cf_firststage.reg <- lm(D ~ (1 + Z) * X_IV * bs(X_minus, df = 20),
+             data = boot.data)
+         boot.data$K <- cf_firststage.reg$residuals
+         cf_secondstage.reg <- lm(
+             Y ~ (1 + Z * D) + X_minus + bs(K, knots = seq(-1, 1, by = 0.05)),
+             data = boot.data)
+         cf.est <- estimated.values(cf_firststage.reg, cf_secondstage.reg, boot.data)
+         # Save the outputs.
+         ols_direct_effect[i]     <- ols.est$`direct-effect`
+         ols_indirect_effect[i]   <- ols.est$`indirect-effect`
+         cf_direct_effect[i]      <- cf.est$`direct-effect`
+         cf_indirect_effect[i]    <- cf.est$`indirect-effect`
+     }
+     # Return the bootstrap data.
+     output.list <- list()
+     output.list$data <- data.frame(
+         truth_direct_effect   = rep(as.numeric(truth.est$average_direct_effect), boot.reps),
+         ols_direct_effect     = ols_direct_effect,
+         cf_direct_effect      = cf_direct_effect,
+         truth_indirect_effect = rep(as.numeric(truth.est$average_indirect_effect), boot.reps),
+         ols_indirect_effect   = ols_indirect_effect,
+         cf_indirect_effect    = cf_indirect_effect
+     )
+     # Calculate the needed statistics, to return
+     output.list$estimates <- data.frame(
+         # Truth
+         truth_direct_effect     = as.numeric(truth.est$average_direct_effect),
+         truth_indirect_effect   = as.numeric(truth.est$average_indirect_effect),
+         # OLS mean, and the 95% confidence intervals
+         ols_direct_effect       = as.numeric(mean(ols_direct_effect)),
+         ols_direct_effect_se    = as.numeric(sd(ols_direct_effect)),
+         ols_direct_effect_up    = as.numeric(quantile(ols_direct_effect, probs = 0.975)),
+         ols_direct_effect_low   = as.numeric(quantile(ols_direct_effect, probs = 0.025)),
+         ols_indirect_effect     = as.numeric(mean(ols_indirect_effect)),
+         ols_indirect_effect_se  = as.numeric(sd(ols_indirect_effect)),
+         ols_indirect_effect_up  = as.numeric(quantile(ols_indirect_effect, probs = 0.975)),
+         ols_indirect_effect_low = as.numeric(quantile(ols_indirect_effect, probs = 0.025)),
+         # Control Fun mean, and the 95% confidence intervals
+         cf_direct_effect        = as.numeric(mean(cf_direct_effect)),
+         cf_direct_effect_se     = as.numeric(sd(cf_direct_effect)),
+         cf_direct_effect_up     = as.numeric(quantile(cf_direct_effect, probs = 0.975)),
+         cf_direct_effect_low    = as.numeric(quantile(cf_direct_effect, probs = 0.025)),
+         cf_indirect_effect      = as.numeric(mean(cf_indirect_effect)),
+         cf_indirect_effect_se   = as.numeric(sd(cf_indirect_effect)),
+         cf_indirect_effect_up   = as.numeric(quantile(cf_indirect_effect, probs = 0.975)),
+         cf_indirect_effect_low  = as.numeric(quantile(cf_indirect_effect, probs = 0.025))
+     )
+     return(output.list)
+ }
> 
> 
> ################################################################################
> ## Compare estimation methods, in one simulation.
> 
> ## Simulate the data: rho, sigma_0, sigma_1, sigma_C = 0.5, 1, 2, 1.
> simulated.data <- simulate.data(0.5, 1, 2, 0.01)
> # SHow the theoretical direct + indirect values
> print("How many mediator compliers in the sample?")
[1] "How many mediator compliers in the sample?"
> print(table(simulated.data$D_1, simulated.data$D_0) / NROW(simulated.data))
   
         0      1
  0 0.2273 0.0000
  1 0.6575 0.1152
> print(theoretical.values(simulated.data))
$average_first_stage
[1] 0.6575

$average_direct_effect
[1] 1.4382

$average_indirect_effect
[1] 1.14452

> 
> # Show that the regression specification holds exactly (after debiasing outcome).
> true_firststage.reg <- probit(D ~ (1 + Z) + X_minus + X_IV, data = simulated.data)
> true_secondstage.reg <- lm(I(Y - (1 - D) * U_0) ~ (1 + Z * D) + X_minus + D * U_1,
+     data = simulated.data)
> print(theoretical.values(simulated.data))
$average_first_stage
[1] 0.6575

$average_direct_effect
[1] 1.4382

$average_indirect_effect
[1] 1.14452

> print(estimated.values(true_firststage.reg, true_secondstage.reg, simulated.data))
$`first-stage`
[1] 0.6592978

$`direct-effect`
[1] 1.4382

$`indirect-effect`
[1] 0.9916884

> # This is because the truth second-stage is perfect:
> print(summary(true_secondstage.reg))

Call:
lm(formula = I(Y - (1 - D) * U_0) ~ (1 + Z * D) + X_minus + D * 
    U_1, data = simulated.data)

Residuals:
       Min         1Q     Median         3Q        Max 
-2.636e-12 -1.700e-15 -6.000e-16  2.000e-16  1.062e-11 

Coefficients:
             Estimate Std. Error   t value Pr(>|t|)    
(Intercept) 8.868e-14  5.113e-15 1.734e+01  < 2e-16 ***
Z           1.000e+00  3.988e-15 2.508e+14  < 2e-16 ***
D           1.000e+00  5.688e-15 1.758e+14  < 2e-16 ***
X_minus     1.000e+00  1.170e-15 8.550e+14  < 2e-16 ***
U_1         6.473e-15  8.346e-16 7.756e+00 9.61e-15 ***
Z:D         1.000e+00  6.587e-15 1.518e+14  < 2e-16 ***
D:U_1       1.000e+00  1.273e-15 7.857e+14  < 2e-16 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 1.101e-13 on 9993 degrees of freedom
Multiple R-squared:      1,	Adjusted R-squared:      1 
F-statistic: 6.554e+29 on 6 and 9993 DF,  p-value: < 2.2e-16

> 
> # Show how the OLS result gives a bias result (if rho != 0)
> ols_firststage.reg <- lm(D ~ (1 + Z) + X_minus + X_IV, data = simulated.data)
> ols_secondstage.reg <- lm(Y ~ 1 + Z * D + X_minus, data = simulated.data)
> print(theoretical.values(simulated.data))
$average_first_stage
[1] 0.6575

$average_direct_effect
[1] 1.4382

$average_indirect_effect
[1] 1.14452

> print(estimated.values(ols_firststage.reg, ols_secondstage.reg, simulated.data))
$`first-stage`
[1] 0.6593643

$`direct-effect`
[1] 0.4525525

$`indirect-effect`
[1] 2.149712

> 
> # Show how (unknown) control function gets it correct, in 2 steps (with splines)
> cf_firststage.reg <- lm(D ~ (1 + Z) * X_IV * bs(X_minus, df = 20),
+     data = simulated.data)
> simulated.data$K <- cf_firststage.reg$residuals
> cf_secondstage.reg <- lm(Y ~ (1 + Z * D) + X_minus +
+     bs(K, knots = seq(-1.05, 1.05, by = 0.05)),
+     data = simulated.data)
> summary(cf_secondstage.reg)

Call:
lm(formula = Y ~ (1 + Z * D) + X_minus + bs(K, knots = seq(-1.05, 
    1.05, by = 0.05)), data = simulated.data)

Residuals:
    Min      1Q  Median      3Q     Max 
-5.7114 -0.8414 -0.0351  0.8201  5.8504 

Coefficients: (4 not defined because of singularities)
                                             Estimate Std. Error t value
(Intercept)                                   6.36351    1.19457   5.327
Z                                             0.87523    0.14396   6.080
D                                             1.20325    0.25344   4.748
X_minus                                       1.02072    0.02801  36.444
bs(K, knots = seq(-1.05, 1.05, by = 0.05))1        NA         NA      NA
bs(K, knots = seq(-1.05, 1.05, by = 0.05))2  -6.38635    1.58872  -4.020
bs(K, knots = seq(-1.05, 1.05, by = 0.05))3  -5.55378    1.55055  -3.582
bs(K, knots = seq(-1.05, 1.05, by = 0.05))4  -6.63819    1.33108  -4.987
bs(K, knots = seq(-1.05, 1.05, by = 0.05))5  -6.22206    1.26164  -4.932
bs(K, knots = seq(-1.05, 1.05, by = 0.05))6  -6.38650    1.24532  -5.128
bs(K, knots = seq(-1.05, 1.05, by = 0.05))7  -6.46366    1.26006  -5.130
bs(K, knots = seq(-1.05, 1.05, by = 0.05))8  -6.13413    1.23553  -4.965
bs(K, knots = seq(-1.05, 1.05, by = 0.05))9  -6.14424    1.24601  -4.931
bs(K, knots = seq(-1.05, 1.05, by = 0.05))10 -6.49959    1.23052  -5.282
bs(K, knots = seq(-1.05, 1.05, by = 0.05))11 -6.33562    1.23175  -5.144
bs(K, knots = seq(-1.05, 1.05, by = 0.05))12 -6.43818    1.21803  -5.286
bs(K, knots = seq(-1.05, 1.05, by = 0.05))13 -6.30558    1.22108  -5.164
bs(K, knots = seq(-1.05, 1.05, by = 0.05))14 -6.39481    1.22635  -5.215
bs(K, knots = seq(-1.05, 1.05, by = 0.05))15 -6.40468    1.21898  -5.254
bs(K, knots = seq(-1.05, 1.05, by = 0.05))16 -6.63340    1.21925  -5.441
bs(K, knots = seq(-1.05, 1.05, by = 0.05))17 -6.49624    1.20122  -5.408
bs(K, knots = seq(-1.05, 1.05, by = 0.05))18 -6.64768    1.19418  -5.567
bs(K, knots = seq(-1.05, 1.05, by = 0.05))19 -6.39524    1.18827  -5.382
bs(K, knots = seq(-1.05, 1.05, by = 0.05))20 -6.51119    1.17980  -5.519
bs(K, knots = seq(-1.05, 1.05, by = 0.05))21 -6.35667    1.17269  -5.421
bs(K, knots = seq(-1.05, 1.05, by = 0.05))22 -6.47923    1.17524  -5.513
bs(K, knots = seq(-1.05, 1.05, by = 0.05))23 -6.46090    1.16480  -5.547
bs(K, knots = seq(-1.05, 1.05, by = 0.05))24 -6.32373    1.16174  -5.443
bs(K, knots = seq(-1.05, 1.05, by = 0.05))25 -6.27063    1.15762  -5.417
bs(K, knots = seq(-1.05, 1.05, by = 0.05))26 -6.00377    1.16073  -5.172
bs(K, knots = seq(-1.05, 1.05, by = 0.05))27 -5.84667    1.16771  -5.007
bs(K, knots = seq(-1.05, 1.05, by = 0.05))28 -5.62993    1.16635  -4.827
bs(K, knots = seq(-1.05, 1.05, by = 0.05))29 -6.14049    1.17148  -5.242
bs(K, knots = seq(-1.05, 1.05, by = 0.05))30 -5.07045    1.16923  -4.337
bs(K, knots = seq(-1.05, 1.05, by = 0.05))31 -5.69551    1.17231  -4.858
bs(K, knots = seq(-1.05, 1.05, by = 0.05))32 -5.34532    1.17925  -4.533
bs(K, knots = seq(-1.05, 1.05, by = 0.05))33 -5.25388    1.18535  -4.432
bs(K, knots = seq(-1.05, 1.05, by = 0.05))34 -5.62258    1.19386  -4.710
bs(K, knots = seq(-1.05, 1.05, by = 0.05))35 -4.07518    1.20267  -3.388
bs(K, knots = seq(-1.05, 1.05, by = 0.05))36 -4.91044    1.20702  -4.068
bs(K, knots = seq(-1.05, 1.05, by = 0.05))37 -4.44413    1.22290  -3.634
bs(K, knots = seq(-1.05, 1.05, by = 0.05))38 -4.41507    1.18534  -3.725
bs(K, knots = seq(-1.05, 1.05, by = 0.05))39 -4.14566    1.22250  -3.391
bs(K, knots = seq(-1.05, 1.05, by = 0.05))40 -3.63443    1.15151  -3.156
bs(K, knots = seq(-1.05, 1.05, by = 0.05))41 -3.37204    1.25611  -2.685
bs(K, knots = seq(-1.05, 1.05, by = 0.05))42 -3.31783    1.11633  -2.972
bs(K, knots = seq(-1.05, 1.05, by = 0.05))43 -3.33360    1.62994  -2.045
bs(K, knots = seq(-1.05, 1.05, by = 0.05))44       NA         NA      NA
bs(K, knots = seq(-1.05, 1.05, by = 0.05))45       NA         NA      NA
bs(K, knots = seq(-1.05, 1.05, by = 0.05))46       NA         NA      NA
Z:D                                           1.03392    0.17498   5.909
                                             Pr(>|t|)    
(Intercept)                                  1.02e-07 ***
Z                                            1.25e-09 ***
D                                            2.09e-06 ***
X_minus                                       < 2e-16 ***
bs(K, knots = seq(-1.05, 1.05, by = 0.05))1        NA    
bs(K, knots = seq(-1.05, 1.05, by = 0.05))2  5.87e-05 ***
bs(K, knots = seq(-1.05, 1.05, by = 0.05))3  0.000343 ***
bs(K, knots = seq(-1.05, 1.05, by = 0.05))4  6.23e-07 ***
bs(K, knots = seq(-1.05, 1.05, by = 0.05))5  8.28e-07 ***
bs(K, knots = seq(-1.05, 1.05, by = 0.05))6  2.98e-07 ***
bs(K, knots = seq(-1.05, 1.05, by = 0.05))7  2.96e-07 ***
bs(K, knots = seq(-1.05, 1.05, by = 0.05))8  6.99e-07 ***
bs(K, knots = seq(-1.05, 1.05, by = 0.05))9  8.31e-07 ***
bs(K, knots = seq(-1.05, 1.05, by = 0.05))10 1.30e-07 ***
bs(K, knots = seq(-1.05, 1.05, by = 0.05))11 2.75e-07 ***
bs(K, knots = seq(-1.05, 1.05, by = 0.05))12 1.28e-07 ***
bs(K, knots = seq(-1.05, 1.05, by = 0.05))13 2.47e-07 ***
bs(K, knots = seq(-1.05, 1.05, by = 0.05))14 1.88e-07 ***
bs(K, knots = seq(-1.05, 1.05, by = 0.05))15 1.52e-07 ***
bs(K, knots = seq(-1.05, 1.05, by = 0.05))16 5.44e-08 ***
bs(K, knots = seq(-1.05, 1.05, by = 0.05))17 6.52e-08 ***
bs(K, knots = seq(-1.05, 1.05, by = 0.05))18 2.66e-08 ***
bs(K, knots = seq(-1.05, 1.05, by = 0.05))19 7.53e-08 ***
bs(K, knots = seq(-1.05, 1.05, by = 0.05))20 3.50e-08 ***
bs(K, knots = seq(-1.05, 1.05, by = 0.05))21 6.08e-08 ***
bs(K, knots = seq(-1.05, 1.05, by = 0.05))22 3.61e-08 ***
bs(K, knots = seq(-1.05, 1.05, by = 0.05))23 2.98e-08 ***
bs(K, knots = seq(-1.05, 1.05, by = 0.05))24 5.35e-08 ***
bs(K, knots = seq(-1.05, 1.05, by = 0.05))25 6.21e-08 ***
bs(K, knots = seq(-1.05, 1.05, by = 0.05))26 2.36e-07 ***
bs(K, knots = seq(-1.05, 1.05, by = 0.05))27 5.62e-07 ***
bs(K, knots = seq(-1.05, 1.05, by = 0.05))28 1.41e-06 ***
bs(K, knots = seq(-1.05, 1.05, by = 0.05))29 1.62e-07 ***
bs(K, knots = seq(-1.05, 1.05, by = 0.05))30 1.46e-05 ***
bs(K, knots = seq(-1.05, 1.05, by = 0.05))31 1.20e-06 ***
bs(K, knots = seq(-1.05, 1.05, by = 0.05))32 5.89e-06 ***
bs(K, knots = seq(-1.05, 1.05, by = 0.05))33 9.42e-06 ***
bs(K, knots = seq(-1.05, 1.05, by = 0.05))34 2.52e-06 ***
bs(K, knots = seq(-1.05, 1.05, by = 0.05))35 0.000706 ***
bs(K, knots = seq(-1.05, 1.05, by = 0.05))36 4.77e-05 ***
bs(K, knots = seq(-1.05, 1.05, by = 0.05))37 0.000280 ***
bs(K, knots = seq(-1.05, 1.05, by = 0.05))38 0.000197 ***
bs(K, knots = seq(-1.05, 1.05, by = 0.05))39 0.000699 ***
bs(K, knots = seq(-1.05, 1.05, by = 0.05))40 0.001603 ** 
bs(K, knots = seq(-1.05, 1.05, by = 0.05))41 0.007276 ** 
bs(K, knots = seq(-1.05, 1.05, by = 0.05))42 0.002965 ** 
bs(K, knots = seq(-1.05, 1.05, by = 0.05))43 0.040858 *  
bs(K, knots = seq(-1.05, 1.05, by = 0.05))44       NA    
bs(K, knots = seq(-1.05, 1.05, by = 0.05))45       NA    
bs(K, knots = seq(-1.05, 1.05, by = 0.05))46       NA    
Z:D                                          3.56e-09 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 1.335 on 9953 degrees of freedom
Multiple R-squared:  0.6704,	Adjusted R-squared:  0.6689 
F-statistic: 440.2 on 46 and 9953 DF,  p-value: < 2.2e-16

> print(theoretical.values(simulated.data))
$average_first_stage
[1] 0.6575

$average_direct_effect
[1] 1.4382

$average_indirect_effect
[1] 1.14452

> print(estimated.values(cf_firststage.reg, cf_secondstage.reg, simulated.data))
$`first-stage`
[1] 0.6594903

$`direct-effect`
[1] 1.328295

$`indirect-effect`
[1] 1.129813

> 
> #! Test, get compliers correct
> #! -> needs a different weighting scheme
> #! -> Abadie (2003) kappa weights do not get it correct.
> library(mgcv)
> cf_firststage.reg <- lm(D ~ (1 + Z) * X_IV * bs(X_minus, df = 20),
+     data = simulated.data)
> complier.weights <- predict(
+     cf_firststage.reg, newdata = mutate(simulated.data, Z = 1), type = "response") - predict(
+         cf_firststage.reg, newdata = mutate(simulated.data, Z = 0), type = "response")
> complier.weights[complier.weights < 0] <- 0
> complier_secondstage.reg <- lm(Y ~ (1 + Z * D) + X_minus +
+     bs(K, knots = seq(-1.1, 1.1, by = 0.05)),
+     weights = complier.weights,
+     data = simulated.data)
> print(theoretical.values(simulated.data))
$average_first_stage
[1] 0.6575

$average_direct_effect
[1] 1.4382

$average_indirect_effect
[1] 1.14452

> print(estimated.values(cf_firststage.reg, complier_secondstage.reg, simulated.data))
$`first-stage`
[1] 0.6594903

$`direct-effect`
[1] 1.331646

$`indirect-effect`
[1] 1.120083

> 
> #! Test: including the K_0 and K_1 terms in complier gains
> simulated.data$K_0 <- (1 - simulated.data$D) * cf_firststage.reg$residuals
> simulated.data$K_1 <- simulated.data$D * cf_firststage.reg$residuals
> complier_secondstage.reg <- gam(Y ~ (1 + Z * D) + X_minus +
+     s(K_0, bs = "cr", k = 20) +
+     s(K_1, bs = "cr", k = 20),
+     data = simulated.data)
> # calculate the second-stage indirect effect
> firststage.est <- predict(
+     cf_firststage.reg, newdata = mutate(simulated.data, Z = 1), type = "response") - predict(
+         cf_firststage.reg, newdata = mutate(simulated.data, Z = 0), type = "response")
> indirect.est <- predict(
+     cf_secondstage.reg, newdata = mutate(simulated.data, D = 1, K_0 = 0)) -
+         predict(cf_secondstage.reg, newdata = mutate(simulated.data, D = 0, K_1 = 0))
> # Show the means
> print(mean(firststage.est * indirect.est))
[1] 1.129813
> print(theoretical.values(simulated.data))
$average_first_stage
[1] 0.6575

$average_direct_effect
[1] 1.4382

$average_indirect_effect
[1] 1.14452

> # Compared the un-weighted version (which has group differences bias).
> print(estimated.values(cf_firststage.reg, cf_secondstage.reg, simulated.data))
$`first-stage`
[1] 0.6594903

$`direct-effect`
[1] 1.328295

$`indirect-effect`
[1] 1.129813

> 
> 
> 
> # Estimate the AIE by a kappa-weighted second-stage.
> # Requires writing an R function for accepting the possible -ve kappa weight.
> est_probZ <- glm(Z ~ 1 + bs(X_minus, df = 20) * X_IV, data = simulated.data)
> hat_probZ <- as.numeric(est_probZ$fitted)
> # hat_probZ <- 0.5
> Z <- simulated.data$Z
> D <- simulated.data$D
> kappa_1 <- D * ((Z - hat_probZ) / ((1 - hat_probZ) * hat_probZ))
> kappa_0 <- (1 - D) * (((1 - Z) - (1 - hat_probZ)) / ((1 - hat_probZ) * hat_probZ))
> kappa <- kappa_1 * hat_probZ + kappa_0 * (1 - hat_probZ)
> 
> y.matrix <- matrix(simulated.data$Y)
> control.fun <- bs(simulated.data$K, df = 10)#knots = seq(-1, 1, by = 0.2))
> reg.matrix <- cbind(1, simulated.data$Z,
+     simulated.data$D,
+     simulated.data$Z * simulated.data$D,
+     simulated.data$X_minus,
+     control.fun)
> wls.coef <- solve(
+     t(reg.matrix * kappa) %*% reg.matrix) %*% t(reg.matrix * kappa
+         )  %*% y.matrix
> wls.est <- as.numeric(reg.matrix %*% wls.coef)
> 
> firststage.est <- predict(
+     cf_firststage.reg, newdata = mutate(simulated.data, Z = 1), type = "response") - predict(
+         cf_firststage.reg, newdata = mutate(simulated.data, Z = 0), type = "response")
> # calculate the second-stage indirect effect
> indirect.est <- as.numeric(
+     cbind(1, simulated.data$Z, 1, simulated.data$Z,
+         simulated.data$X_minus, control.fun) %*% wls.coef) -
+     as.numeric(cbind(1, simulated.data$Z, 0, 0,
+         simulated.data$X_minus, control.fun) %*% wls.coef)
> # Show the complier means
> print(mean(indirect.est * firststage.est))
[1] 1.109788
> print(theoretical.values(simulated.data))
$average_first_stage
[1] 0.6575

$average_direct_effect
[1] 1.4382

$average_indirect_effect
[1] 1.14452

> 
> # Compared the un-weighted version (which has group differences bias).
> print(estimated.values(cf_firststage.reg, cf_secondstage.reg, simulated.data))
$`first-stage`
[1] 0.6594903

$`direct-effect`
[1] 1.328295

$`indirect-effect`
[1] 1.129813

> 
> 
> #! Test: note the difference between AIE and LAIE.
> # show gains to D, on average
> print(mean(simulated.data$Z * (simulated.data$Y_1_1 - simulated.data$Y_1_0) +
+     (1 - simulated.data$Z) * (simulated.data$Y_0_1 - simulated.data$Y_0_0)))
[1] 1.514507
> # show gains to D, among compliers
> print(mean((simulated.data$Z * (simulated.data$Y_1_1 - simulated.data$Y_1_0) +
+     (1 - simulated.data$Z) * (simulated.data$Y_0_1 - simulated.data$Y_0_0)) * (
+         simulated.data$D_1 == 1 & simulated.data$D_0 == 0)))
[1] 1.14452
> # Todo: estimate the AIE by a kappa-weighted second-stage.
> # Requires writing an R function for accepting the possible -ve kappa weight.
> library(LARF)
> est_probZ <- glm(Z ~ 1 + poly(X_minus, 3) * X_IV, data = simulated.data)
> hat_probZ <- est_probZ$fitted
> hat_probZ <- 0.5
> Z <- simulated.data$Z
> D <- simulated.data$D
> 
> kappa_1 <- D * ((Z - hat_probZ) / ((1 - hat_probZ) * hat_probZ))
> kappa_0 <- (1 - D) * (((1 - Z) - (1 - hat_probZ)) / ((1 - hat_probZ) * hat_probZ))
> kappa <- kappa_1 * hat_probZ + kappa_0 * (1 - hat_probZ)
> table(kappa_0, kappa_1)
       kappa_1
kappa_0   -2    0    2
     -2    0 1118    0
     0   570    0 3812
     2     0 4500    0
> # Code from LARF package for estimating OLS with possibly negative kappa weights.
> # solve ( t(cbind(d,X) * kappa) %*% cbind(d,X)) %*% t(cbind(d,X) * kappa)  %*% y
> 
> 
> ################################################################################
> ## Plot bootstrap results for one DGP
> 
> # Base data to test out.
> simulated.data <- simulate.data(0.5, 1, 2, 0.25)
> 
> # Get bootstrapped point est for the CF approach
> boot.reps <- 10000
> boot.est <- estimated.bootstrap(boot.reps, simulated.data,
+     print.progress = TRUE)
