
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> #!/usr/bin/R
> ## Senan Hogan-Hennessy, 16 Jan 2025
> ## Simulate the system for indirect + direct effects, with Roy selection.
> # Show the date:
> print(format(Sys.time(), "%H:%M %Z %A, %d %B %Y"))
[1] "13:50 EST Monday, 10 February 2025"
> 
> ## Load libraries
> # Functions for data manipulation and visualisation
> library(tidyverse)
── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──
✔ dplyr     1.1.4     ✔ readr     2.1.5
✔ forcats   1.0.0     ✔ stringr   1.5.1
✔ ggplot2   3.5.1     ✔ tibble    3.2.1
✔ lubridate 1.9.3     ✔ tidyr     1.3.1
✔ purrr     1.0.2     
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors
> # Library for better colour choice.
> library(ggthemes)
> # Library for equations in plots
> library(latex2exp)
> # Causal medation package, Imai Keele Yamamoto (2010)
> library(mediation)
Loading required package: MASS

Attaching package: ‘MASS’

The following object is masked from ‘package:dplyr’:

    select

Loading required package: Matrix

Attaching package: ‘Matrix’

The following objects are masked from ‘package:tidyr’:

    expand, pack, unpack

Loading required package: mvtnorm
Loading required package: sandwich
mediation: Causal Mediation Analysis
Version: 4.5.0

> # Package for classical selection estimators (i.e., MLE)
> library(sampleSelection)
Loading required package: maxLik
Loading required package: miscTools

Please cite the 'maxLik' package as:
Henningsen, Arne and Toomet, Ott (2011). maxLik: A package for maximum likelihood estimation in R. Computational Statistics 26(3), 443-458. DOI 10.1007/s00180-010-0217-1.

If you have questions, suggestions, or comments regarding the 'maxLik' package, please use a forum or 'tracker' at maxLik's R-Forge site:
https://r-forge.r-project.org/projects/maxlik/
> # Package for semi-parametric regressor
> library(splines)
> 
> ## Set up the R environment
> # set.seed(47)
> # Define number of digits in tables and graphs
> digits.no <- 3
> # Define where output files go.
> output.folder <- file.path("sim-output")
> # Set the options for the plot sizes, in saving ggplot output.
> fig.height <- 10
> fig.width <- fig.height
> 
> # Define the sample size to work with.
> sample.N <- 10^4
> 
> 
> ################################################################################
> ## Define a function to simulate data in the triangular system.
> 
> # Define a function to simulate all observed + unobserved data 
> simulate.data <- function(rho, sigma_0, sigma_1, sigma_C,
+         sample.size = sample.N){
+     ### Inputs:
+     ## X, a matrix of covariates, continuous or binary values.
+     ## rho \in [-1, +1] measuring correlation between U_0, U_1.
+     ## sigma_0 >= 0 measuring standard deviation of U_0.
+     ## sigma_1 >= 0 measuring standard deviation of U_1.
+     ## sigma_C >= 0 measuring standard deviation of U_C.
+     ## sample.size: integer, representing output sample size i.e., N.
+     # First covariate (\vec X_i^-)
+     X_minus <- 4 + rnorm(sample.size, mean = 0, sd = 1)
+     # Second covariate (instrument for the control function).
+     X_IV <- rbinom(sample.size, 1, 1 / 2)
+     # Simulate the unobserved error terms.
+     U_both <- MASS::mvrnorm(
+         n = sample.size,
+         mu = c(0, 0, 0),
+         Sigma = matrix(c(
+             sigma_0^2,                rho * sigma_0 * sigma_1,  0,
+             rho * sigma_0 * sigma_1,  sigma_1^2,                0,
+             0,                        0,                        sigma_C^2), ncol = 3),
+         empirical = FALSE)
+     U_0 <- U_both[, 1]
+     U_1 <- U_both[, 2]
+     U_C <- U_both[, 3]
+     # Define the mean potential outcomes.
+     mu_outcome_z_d_X <- function(z, d, x_minus){
+         return(x_minus + (z + d + z * d))
+     }
+     mu_cost_z_X <- function(z, x_minus, x_iv){
+         return(- 3 * z + x_minus - x_iv)
+     }
+     # Y_i(Z, D) = mu_D(Z; X_i) + U_D
+     Y_0_0 <- mu_outcome_z_d_X(0, 0, X_minus) + U_0
+     Y_0_1 <- mu_outcome_z_d_X(0, 1, X_minus) + U_1
+     Y_1_0 <- mu_outcome_z_d_X(1, 0, X_minus) + U_0
+     Y_1_1 <- mu_outcome_z_d_X(1, 1, X_minus) + U_1
+     # D_i(Z)= 1{ Y(Z, 1) - Y(Z, 0) >= C_i }
+     D_0 <- as.integer(Y_0_1 - Y_0_0 >= mu_cost_z_X(0, X_minus, X_IV) + U_C)
+     D_1 <- as.integer(Y_1_1 - Y_1_0 >= mu_cost_z_X(1, X_minus, X_IV) + U_C)
+     # Generate the individual effects (direct + indirect)
+     probZ <- 0.5
+     Z <- rbinom(sample.size, 1, probZ)
+     # Observed outcomes: D, Y
+     D <- (Z * D_1) + ((1 - Z) * D_0)
+     # Generate the list of observed outcomes
+     Y <- (Z * D * Y_1_1) +
+         (Z * (1 - D) * Y_1_0) +
+         ((1 - Z) * D * Y_0_1) +
+         ((1 - Z) * (1 - D) * Y_0_0)
+     # Put these data to a coherent data frame.
+     combined.data <- data.frame(
+         # Observed data
+         Z, D, Y,  X_minus, X_IV,
+         # Unobserved, potential outcomes and compliance.
+         D_0, D_1,
+         Y_0_0, Y_0_1, Y_1_0, Y_1_1,
+         #mu0_Z0_X, mu1_Z0_X, mu0_Z1_X, mu1_Z1_X, muC_Z0_X, muC_Z1_X, 
+         U_0, U_1, U_C)
+     # Return the simulated data as a data frame.
+     return(combined.data)
+ }
> 
> 
> ################################################################################
> ## Define a function to show the theoretical values for the data.
> theoretical.values <- function(sim.data, digits.no = 3, print.truth = FALSE){
+     ### Inputs:
+     ## sim.data, a data frame simulated from above.
+     # Extract the potentials from simulated data.
+     Z <- sim.data$Z
+     D <- sim.data$D
+     Y <- sim.data$Y
+     X_minus <- sim.data$X_minus
+     X_IV <- sim.data$X_IV
+     D_0 <- sim.data$D_0
+     D_1 <- sim.data$D_1
+     Y_0_0 <- sim.data$Y_0_0
+     Y_0_1 <- sim.data$Y_0_1
+     Y_1_0 <- sim.data$Y_1_0
+     Y_1_1 <- sim.data$Y_1_1
+     U_0 <- sim.data$U_0
+     U_1 <- sim.data$U_1
+     U_C <- sim.data$U_C
+     # Get the true first-stage effects
+     first_stage <- D_1 - D_0
+     average_first_stage <- mean(first_stage)
+     # Get the theoretical total effect/reduced form/ITT
+     total_effect <-
+         (Y_1_1 - Y_0_0) * (D_1 == 1 & D_0 == 0) +
+         (Y_1_1 - Y_0_1) * (D_1 == 1 & D_0 == 1) +
+         (Y_1_0 - Y_0_0) * (D_1 == 0 & D_0 == 0)
+     average_total_effect <- mean(total_effect)
+     # Get the theoretical indirect effect.
+     indirect_effect <-
+         (Z * (Y_1_1 - Y_1_0) + (1 - Z) * (Y_0_1 - Y_0_0)) * (D_1 == 1 & D_0 == 0)
+     average_indirect_effect <- mean(indirect_effect)
+     # Get the theoretical direct effect.
+     direct_effect <- #(D * (Y_1_1 - Y_0_1) + (1 - D) * (Y_1_0 - Y_0_0))
+         (D * (Y_1_1 - Y_0_1) + (1 - D) * (Y_1_0 - Y_0_0)) * (D_1 == 1 & D_0 == 0) +
+         (Y_1_1 - Y_0_1) * (D_1 == 1 & D_0 == 1) +
+         (Y_1_0 - Y_0_0) * (D_1 == 0 & D_0 == 0)
+     average_direct_effect <- mean(direct_effect)
+     # Show the real underlying values.
+     if (print.truth == TRUE){
+         print("Here is a summary of the (unobserved) true effects:")
+         # Show how many ATs, NTs, Compliers in terms of D_i(Z) for Z = 0, 1.
+         print("How many compliers in the system?")
+         print(table(D_1, D_0) / NROW(sim.data))
+         # Show the real treatment effects
+         print(paste0(c("The average total effect:",    as.numeric(average_total_effect))))
+         print(paste0(c("The average first-stage:",     as.numeric(average_first_stage))))
+         print(paste0(c("The average direct effect:",   as.numeric(average_direct_effect))))
+         print(paste0(c("The average indirect effect:", as.numeric(average_indirect_effect))))
+     
+     }
+     # Define a named list to return
+     output.list <- list(
+         average_first_stage     = average_first_stage,
+         average_total_effect    = average_total_effect,
+         average_direct_effect   = average_direct_effect,
+         average_indirect_effect = average_indirect_effect)
+     # Return the output.list
+     return(output.list)
+ }
> 
> ################################################################################
> ## Define a function to estimate mediation, given the first + second-stages.
> 
> # Estimate the values, given a first and second-stages
> estimated.values <- function(firststage.reg, secondstage.reg, example.data){
+     ### Inputs:
+     ## example.data, a data frame simulated from above.
+     # calculate the first-stage by prediction
+     firststage.est <- predict(
+         firststage.reg, newdata = mutate(example.data, Z = 1), type = "response") - predict(
+             firststage.reg, newdata = mutate(example.data, Z = 0), type = "response")
+     # calculate the second-stage direct effect
+     direct.est <- predict(
+         secondstage.reg, newdata = mutate(example.data, Z = 1)) -
+         predict(secondstage.reg, newdata = mutate(example.data, Z = 0))
+     # calculate the second-stage indirect effect
+     indirect.est <- predict(
+         secondstage.reg, newdata = mutate(example.data, D = 1)) -
+         predict(secondstage.reg, newdata = mutate(example.data, D = 0))
+     # Add on the K_0, K_1 conditional on D_i = 0, 1 respectively for compliers.
+     # # Estimate the kappa-weight
+     # hat_probZ <- 0.5
+     # kappa_1 <- example.data$D * ((example.data$Z - hat_probZ) / (
+     #     (1 - hat_probZ) * hat_probZ))
+     # kappa_0 <- (1 - example.data$D) * (((1 - example.data$Z) - (1 - hat_probZ)) / (
+     #     (1 - hat_probZ) * hat_probZ))
+     # kappa.weight <- kappa_1 * hat_probZ + kappa_0 * (1 - hat_probZ)
+     # # Calculate the term to add on.
+     # add.term <- (weighted.mean(predict(secondstage.reg, newdata = mutate(
+     #     filter(example.data, D == 1), Z = 0, D = 0, X_minus = 0, K_0 = 0)),
+     #         kappa.weight[example.data$D == 1])
+     #     - weighted.mean(predict(secondstage.reg, newdata = mutate(
+     #         filter(example.data, D == 0), Z = 0, D = 0, X_minus = 0, K_1 = 0)),
+     #             kappa.weight[example.data$D == 0]))
+     # indirect.est <- indirect.est + add.term
+     # Return the mean estimates.
+     output.list <- list(
+         "first-stage"     = mean(firststage.est, na.rm = TRUE),
+         "direct-effect"   = mean(direct.est, na.rm = TRUE),
+         "indirect-effect" = mean(firststage.est * indirect.est, na.rm = TRUE))
+     # Return the output.list
+     return(output.list)
+ }
> 
> # Bootstrap the estimates.
> estimated.loop <- function(boot.reps, example.data, bootstrap = TRUE){
+     # Define lists the will be returned:
+     # 2. Naive OLS.
+     ols_direct_effect <- c()
+     ols_indirect_effect <- c()
+     # 3. Control function.
+     cf_direct_effect <- c()
+     cf_indirect_effect <- c()
+     # More in the future ....
+     ## Loop across the bootstraps values.
+     for (i in seq(1, boot.reps)){
+         # If bootstrapping, just resample from provided data.
+         if (bootstrap == TRUE) {
+             boot.indicies <- sample(
+                 seq(1, NROW(example.data)), NROW(example.data), replace = TRUE)
+             boot.data <- example.data[boot.indicies, ]
+         }
+         # If a regular re-simulation, get new data.
+         else if (bootstrap == FALSE){
+             boot.data <- simulate.data(0.5, 1, 2, 0.25)
+             if ((100 * (i / boot.reps)) %% 1 == 0) {
+                 print(paste0(i, " out of ", boot.reps, ", ", 100 * (i / boot.reps), "% done."))
+             }
+         }
+         else {stop("The `bootstrap' option only takes values of TRUE or FALSE.")}
+         # Calculate the truth values, given the simulated data
+         truth.est <- theoretical.values(example.data)
+         # Now get the mediation effects, by different approaches.
+         # 2. OLS estimate of second-stage
+         ols_firststage.reg <- lm(D ~ (1 + Z) + X_minus + X_IV, data = boot.data)
+         ols_secondstage.reg <- lm(Y ~ 1 + Z * D + X_minus, data = boot.data)
+         ols.est <- estimated.values(ols_firststage.reg, ols_secondstage.reg, boot.data)
+         # 3. Control Function estimates.
+         # cf_firststage.reg <- lm(D ~ (1 + Z) * X_IV *
+         #     bs(X_minus, df = 20, intercept = TRUE),
+         #     data = boot.data)
+         # boot.data$K <- cf_firststage.reg$residuals
+         # boot.data$K_0 <- (1 - boot.data$D) * boot.data$K
+         # boot.data$K_1 <- boot.data$D * boot.data$K
+         # cf_secondstage.reg <- lm(
+         #     Y ~ (1 + Z * D) + X_minus +
+         #     bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE) +
+         #     bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE),
+         #     data = boot.data)
+         # cf.est <- estimated.values(cf_firststage.reg, cf_secondstage.reg, boot.data)
+         cf.est <- cf_crossfit_mediate(simulated.data)
+         # Save the outputs.
+         ols_direct_effect[i]   <- ols.est$`direct-effect`
+         ols_indirect_effect[i] <- ols.est$`indirect-effect`
+         cf_direct_effect[i]    <- cf.est$`direct-effect`
+         cf_indirect_effect[i]  <- cf.est$`indirect-effect`
+     }
+     # Return the bootstrap data.
+     output.list <- list()
+     output.list$data <- data.frame(
+         truth_direct_effect   = as.numeric(truth.est$average_direct_effect),
+         ols_direct_effect     = ols_direct_effect,
+         cf_direct_effect      = cf_direct_effect,
+         truth_indirect_effect = as.numeric(truth.est$average_indirect_effect),
+         ols_indirect_effect   = ols_indirect_effect,
+         cf_indirect_effect    = cf_indirect_effect
+     )
+     # Calculate the needed statistics, to return
+     output.list$estimates <- data.frame(
+         # Truth
+         truth_direct_effect     = as.numeric(truth.est$average_direct_effect),
+         truth_indirect_effect   = as.numeric(truth.est$average_indirect_effect),
+         # OLS mean, and the 95% confidence intervals
+         ols_direct_effect       = as.numeric(mean(ols_direct_effect)),
+         ols_direct_effect_se    = as.numeric(sd(ols_direct_effect)),
+         ols_direct_effect_up    = as.numeric(quantile(ols_direct_effect,
+             probs = 0.975, na.rm = TRUE)),
+         ols_direct_effect_low   = as.numeric(quantile(ols_direct_effect,
+             probs = 0.025, na.rm = TRUE)),
+         ols_indirect_effect     = as.numeric(mean(ols_indirect_effect)),
+         ols_indirect_effect_se  = as.numeric(sd(ols_indirect_effect)),
+         ols_indirect_effect_up  = as.numeric(quantile(ols_indirect_effect,
+             probs = 0.975, na.rm = TRUE)),
+         ols_indirect_effect_low = as.numeric(quantile(ols_indirect_effect,
+             probs = 0.025, na.rm = TRUE)),
+         # Control Fun mean, and the 95% confidence intervals
+         cf_direct_effect        = as.numeric(mean(cf_direct_effect)),
+         cf_direct_effect_se     = as.numeric(sd(cf_direct_effect)),
+         cf_direct_effect_up     = as.numeric(quantile(cf_direct_effect,
+             probs = 0.975, na.rm = TRUE)),
+         cf_direct_effect_low    = as.numeric(quantile(cf_direct_effect,
+             probs = 0.025, na.rm = TRUE)),
+         cf_indirect_effect      = as.numeric(mean(cf_indirect_effect)),
+         cf_indirect_effect_se   = as.numeric(sd(cf_indirect_effect)),
+         cf_indirect_effect_up   = as.numeric(quantile(cf_indirect_effect,
+             probs = 0.975, na.rm = TRUE)),
+         cf_indirect_effect_low  = as.numeric(quantile(cf_indirect_effect,
+             probs = 0.025, na.rm = TRUE))
+     )
+     return(output.list)
+ }
> 
> 
> ################################################################################
> ## Define a function to cross-fit the semi-parametric control function.
> 
> cf_crossfit_mediate <- function(example.data){
+     # 1. Calculate the split in half cross-fit samples
+     example.size <- NROW(example.data)    
+     cross.index <- sample(seq(1, example.size),
+         size = 0.5 * example.size, replace = FALSE)
+     firstcross.data <- example.data[cross.index,]
+     secondcross.data <- example.data[-cross.index,]
+     # 2. calculate the CF model in the first cross sample.
+     firstcross_firststage.reg <- lm(D ~ (1 + Z) * X_IV *
+         bs(X_minus, df = 20, intercept = TRUE),
+         data = firstcross.data)
+     firstcross.data$K <- firstcross_firststage.reg$residuals
+     firstcross.data$K_0 <- (1 - firstcross.data$D) * firstcross.data$K
+     firstcross.data$K_1 <- firstcross.data$D * firstcross.data$K
+     firstcross_secondstage.reg <- lm(
+         Y ~ (1 + Z * D) + X_minus +
+         #bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE) +
+         #bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE),
+         D * bs(K, knots = seq(-1, 1, by = 0.05), intercept = FALSE),
+         data = firstcross.data)
+     # 3. calculate the CF model on the second cross sample.
+     secondcross_firststage.reg <- lm(D ~ (1 + Z) * X_IV *
+         bs(X_minus, df = 20, intercept = TRUE),
+         data = secondcross.data)
+     secondcross.data$K <- secondcross_firststage.reg$residuals
+     secondcross.data$K_0 <- (1 - secondcross.data$D) * secondcross.data$K
+     secondcross.data$K_1 <- secondcross.data$D * secondcross.data$K
+     secondcross_secondstage.reg <- lm(
+         Y ~ (1 + Z * D) + X_minus +
+         #bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE) +
+         #bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE),
+         D * bs(K, knots = seq(-1, 1, by = 0.05), intercept = FALSE),
+         data = secondcross.data)
+     # 4. Predict the estimate on the opposite data.
+     firstcross.est <- estimated.values(
+         firstcross_firststage.reg, firstcross_secondstage.reg, secondcross.data)
+     secondcross.est <- estimated.values(
+         secondcross_firststage.reg, secondcross_secondstage.reg, firstcross.data)
+     # Resturn the averaged estimates.
+     output.list <- list(
+         "first-stage"     = mean(c(
+             firstcross.est$`first-stage`, secondcross.est$`first-stage`), na.rm = FALSE),
+         "direct-effect"   = mean(c(
+             firstcross.est$`direct-effect`, secondcross.est$`direct-effect`), na.rm = FALSE),
+         "indirect-effect" = mean(c(
+             firstcross.est$`indirect-effect`, secondcross.est$`indirect-effect`), na.rm = FALSE))
+     # Return the output.list
+     return(output.list)
+ }
> 
> 
> ################################################################################
> ## Compare estimation methods, in one simulation.
> 
> ## Simulate the data: rho, sigma_0, sigma_1, sigma_C = 0.5, 1, 2, 1.
> simulated.data <- simulate.data(0.5, 1, 2, 0.25)
> # SHow the theoretical direct + indirect values
> print(theoretical.values(simulated.data, print.truth = TRUE))
[1] "Here is a summary of the (unobserved) true effects:"
[1] "How many compliers in the system?"
   D_0
D_1      0      1
  0 0.2315 0.0000
  1 0.6488 0.1197
[1] "The average total effect:" "2.57068628655611"         
[1] "The average first-stage:" "0.6488"                  
[1] "The average direct effect:" "1.4463"                    
[1] "The average indirect effect:" "1.12878628655611"            
$average_first_stage
[1] 0.6488

$average_total_effect
[1] 2.570686

$average_direct_effect
[1] 1.4463

$average_indirect_effect
[1] 1.128786

> 
> # Show that the regression specification holds exactly (after debiasing outcome).
> true_firststage.reg <- glm(D ~ (1 + Z) + X_IV +
+     bs(X_minus, df = 5, intercept = TRUE),
+     family = binomial(link = "probit"), data = simulated.data)
> simulated.data$K_0 <- (1 - simulated.data$D) * simulated.data$U_0
> simulated.data$K_1 <- simulated.data$D * simulated.data$U_1
> true_secondstage.reg <- lm(Y ~ (1 + Z * D) + X_minus +
+     # including the unobserved errors: U_0 - (D : U_0) + (D : U_1),
+     K_0 + K_1,
+     data = simulated.data)
> print(theoretical.values(simulated.data))
$average_first_stage
[1] 0.6488

$average_total_effect
[1] 2.570686

$average_direct_effect
[1] 1.4463

$average_indirect_effect
[1] 1.128786

> print(estimated.values(true_firststage.reg, true_secondstage.reg, simulated.data))
$`first-stage`
[1] 0.6469062

$`direct-effect`
[1] 1.4463

$`indirect-effect`
[1] 0.9744515

> print(summary(true_secondstage.reg))

Call:
lm(formula = Y ~ (1 + Z * D) + X_minus + K_0 + K_1, data = simulated.data)

Residuals:
       Min         1Q     Median         3Q        Max 
-4.010e-13 -2.100e-15 -6.000e-16  0.000e+00  6.342e-12 

Coefficients:
             Estimate Std. Error   t value Pr(>|t|)    
(Intercept) 1.243e-13  3.633e-15 3.423e+01   <2e-16 ***
Z           1.000e+00  2.607e-15 3.835e+14   <2e-16 ***
D           1.000e+00  3.967e-15 2.521e+14   <2e-16 ***
X_minus     1.000e+00  8.372e-16 1.194e+15   <2e-16 ***
K_0         1.000e+00  1.054e-15 9.485e+14   <2e-16 ***
K_1         1.000e+00  6.968e-16 1.435e+15   <2e-16 ***
Z:D         1.000e+00  4.518e-15 2.213e+14   <2e-16 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 7.871e-14 on 9993 degrees of freedom
Multiple R-squared:      1,	Adjusted R-squared:      1 
F-statistic: 1.457e+30 on 6 and 9993 DF,  p-value: < 2.2e-16

> 
> # Show how the OLS result gives a bias result (if rho != 0)
> ols_firststage.reg <- lm(D ~ (1 + Z) + X_minus + X_IV, data = simulated.data)
> ols_secondstage.reg <- lm(Y ~ 1 + Z * D + X_minus, data = simulated.data)
> print(theoretical.values(simulated.data))
$average_first_stage
[1] 0.6488

$average_total_effect
[1] 2.570686

$average_direct_effect
[1] 1.4463

$average_indirect_effect
[1] 1.128786

> print(estimated.values(ols_firststage.reg, ols_secondstage.reg, simulated.data))
$`first-stage`
[1] 0.64665

$`direct-effect`
[1] 0.5290025

$`indirect-effect`
[1] 2.045617

> 
> # Show how (unknown) control function gets it correct, in 2 steps (with splines)
> cf_firststage.reg <- lm(D ~ (1 + Z) * X_IV *
+     bs(X_minus, df = 20, intercept = TRUE),
+     data = simulated.data)
> simulated.data$K <- cf_firststage.reg$residuals
> simulated.data$K_0 <- (1 - simulated.data$D) * simulated.data$K
> simulated.data$K_1 <- simulated.data$D * simulated.data$K
> cf_secondstage.reg <- lm(Y ~ (1 + Z * D) + X_minus +
+     bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE) +
+     bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE),
+     data = simulated.data)
> print(summary(cf_secondstage.reg))

Call:
lm(formula = Y ~ (1 + Z * D) + X_minus + bs(K_0, knots = seq(0, 
    1, by = 0.05), intercept = FALSE) + bs(K_1, knots = seq(0, 
    1, by = 0.05), intercept = FALSE), data = simulated.data)

Residuals:
    Min      1Q  Median      3Q     Max 
-5.4432 -0.8623 -0.0367  0.8025  7.1080 

Coefficients: (19 not defined because of singularities)
                                                            Estimate Std. Error
(Intercept)                                                  2.62479    1.15789
Z                                                            0.82194    0.13156
D                                                            1.41284    0.26027
X_minus                                                      1.04729    0.02643
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)1    0.26554    0.40837
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)2   -0.25433    0.20363
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)3   -0.13791    0.26938
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)4    3.18575    5.32481
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)5  -64.66737  100.41380
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)6   -0.94432    1.34709
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)7         NA         NA
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)8         NA         NA
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)9         NA         NA
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)10        NA         NA
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)11        NA         NA
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)12        NA         NA
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)13        NA         NA
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)14        NA         NA
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)15        NA         NA
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)16        NA         NA
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)17        NA         NA
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)18        NA         NA
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)19        NA         NA
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)20        NA         NA
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)21        NA         NA
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)22        NA         NA
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)23        NA         NA
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)24        NA         NA
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)1   -1.91473    1.46719
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)2   -3.15043    1.07734
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)3   -2.57759    1.13572
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)4   -2.79240    1.10348
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)5   -2.34730    1.12078
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)6   -2.29543    1.11030
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)7   -2.50950    1.11945
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)8   -1.23293    1.12705
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)9   -2.30429    1.12581
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)10  -1.84786    1.12924
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)11  -1.60023    1.13031
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)12  -1.72773    1.16486
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)13  -0.90217    1.17235
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)14  -1.79044    1.18165
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)15  -1.12594    1.17230
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)16  -0.87744    1.16617
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)17  -0.71904    1.18417
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)18  -0.72565    1.16506
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)19  -0.96486    1.20837
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)20   0.38936    1.18592
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)21   0.36570    1.22565
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)22   0.56624    1.27950
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)23   1.09399    1.35632
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)24        NA         NA
Z:D                                                          1.03719    0.16893
                                                           t value Pr(>|t|)    
(Intercept)                                                  2.267  0.02342 *  
Z                                                            6.248 4.33e-10 ***
D                                                            5.428 5.82e-08 ***
X_minus                                                     39.631  < 2e-16 ***
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)1    0.650  0.51556    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)2   -1.249  0.21169    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)3   -0.512  0.60870    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)4    0.598  0.54966    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)5   -0.644  0.51958    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)6   -0.701  0.48332    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)7       NA       NA    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)8       NA       NA    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)9       NA       NA    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)10      NA       NA    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)11      NA       NA    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)12      NA       NA    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)13      NA       NA    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)14      NA       NA    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)15      NA       NA    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)16      NA       NA    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)17      NA       NA    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)18      NA       NA    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)19      NA       NA    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)20      NA       NA    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)21      NA       NA    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)22      NA       NA    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)23      NA       NA    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = FALSE)24      NA       NA    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)1   -1.305  0.19191    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)2   -2.924  0.00346 ** 
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)3   -2.270  0.02326 *  
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)4   -2.531  0.01140 *  
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)5   -2.094  0.03625 *  
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)6   -2.067  0.03872 *  
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)7   -2.242  0.02500 *  
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)8   -1.094  0.27401    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)9   -2.047  0.04070 *  
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)10  -1.636  0.10179    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)11  -1.416  0.15688    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)12  -1.483  0.13805    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)13  -0.770  0.44159    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)14  -1.515  0.12975    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)15  -0.960  0.33685    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)16  -0.752  0.45182    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)17  -0.607  0.54372    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)18  -0.623  0.53340    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)19  -0.798  0.42461    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)20   0.328  0.74268    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)21   0.298  0.76543    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)22   0.443  0.65810    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)23   0.807  0.41992    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = FALSE)24      NA       NA    
Z:D                                                          6.140 8.58e-10 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 1.329 on 9966 degrees of freedom
Multiple R-squared:  0.6753,	Adjusted R-squared:  0.6742 
F-statistic: 628.1 on 33 and 9966 DF,  p-value: < 2.2e-16

> print(theoretical.values(simulated.data))
$average_first_stage
[1] 0.6488

$average_total_effect
[1] 2.570686

$average_direct_effect
[1] 1.4463

$average_indirect_effect
[1] 1.128786

> print(estimated.values(cf_firststage.reg, cf_secondstage.reg, simulated.data))
$`first-stage`
[1] 0.6467769

$`direct-effect`
[1] 1.284837

$`indirect-effect`
[1] 1.253559

> 
> # Cross-fit the CF approach to avoid over-fitting bias in the semi-para step.
> print(theoretical.values(simulated.data))
$average_first_stage
[1] 0.6488

$average_total_effect
[1] 2.570686

$average_direct_effect
[1] 1.4463

$average_indirect_effect
[1] 1.128786

> print(cf_crossfit_mediate(simulated.data))
$`first-stage`
[1] 0.6474403

$`direct-effect`
[1] 1.275526

$`indirect-effect`
[1] 5.278204

There were 12 warnings (use warnings() to see them)
> 
> 
> #! Test: Imbens Newey (2009) conditional CDF as the control function.
> library(mgcv)
Loading required package: nlme

Attaching package: ‘nlme’

The following object is masked from ‘package:dplyr’:

    collapse

This is mgcv 1.9-1. For overview type 'help("mgcv-package")'.
> cf_firststage.reg <- lm(D ~ (1 + Z) * X_IV *
+     bs(X_minus, df = 20, intercept = TRUE),
+     data = simulated.data)
> control.fun <- ecdf(cf_firststage.reg$fitted)
> simulated.data$K <- as.numeric(control.fun(cf_firststage.reg$fitted))
> simulated.data$K <- cf_firststage.reg$fitted
> simulated.data$K_0 <- (1 - simulated.data$D) * (1 - simulated.data$K)
> simulated.data$K_1 <- simulated.data$D * simulated.data$K
> cf_secondstage.reg <- gam(Y ~ (1 + Z * D) + X_minus +
+     bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE) +
+     bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE),
+     data = simulated.data)
> print(summary(cf_secondstage.reg))

Family: gaussian 
Link function: identity 

Formula:
Y ~ (1 + Z * D) + X_minus + bs(K_0, knots = seq(0, 1, by = 0.05), 
    intercept = TRUE) + bs(K_1, knots = seq(0, 1, by = 0.05), 
    intercept = TRUE)

Parametric coefficients:
                                                          Estimate Std. Error
(Intercept)                                               -2.72115    1.76369
Z                                                          0.79575    0.13904
D                                                          3.35763    3.22635
X_minus                                                    1.05715    0.02805
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)1   0.00000    0.00000
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)2   2.08030    2.49041
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)3  -1.11587    1.92067
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)4  -0.54893    0.71767
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)5   0.39757    0.50599
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)6  -0.15187    0.38045
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)7   0.28304    0.30600
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)8  -0.39320    0.28805
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)9   0.48304    0.35636
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)10 -0.10670    0.31332
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)11  0.05729    0.28826
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)12 -0.18834    0.27866
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)13 -0.08913    0.34972
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)14 -0.36540    0.39883
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)15 -0.06316    0.37069
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)16 -0.11849    0.28515
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)17 -0.12198    0.25452
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)18 -0.24291    0.25226
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)19 -0.19569    0.20529
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)20 -0.38213    0.21202
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)21 -0.18209    0.18898
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)22 -0.28794    0.18040
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)23 -0.18385    0.26534
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)24 -0.64179    0.59581
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)25 -0.64292    1.04679
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)1   0.00000    0.00000
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)2   2.72260    1.83669
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)3   1.74359    0.95265
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)4   1.49415    0.51602
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)5   1.52351    0.45522
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)6   0.17126    0.45539
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)7   0.41597    0.37752
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)8   0.42260    0.41261
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)9   0.26760    0.37675
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)10  0.01857    0.39068
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)11 -0.63982    0.42722
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)12  0.24684    0.40824
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)13 -0.57765    0.37021
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)14 -0.44421    0.27182
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)15 -0.69536    0.27080
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)16 -1.14203    0.25816
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)17 -0.06789    0.27609
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)18 -1.35220    0.21882
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)19 -1.13047    0.20925
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)20 -1.17530    0.22325
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)21 -1.62235    0.22204
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)22 -1.40600    0.23585
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)23 -1.96301    0.34880
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)24 -0.72491    0.71458
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)25  1.19336    1.08201
Z:D                                                        1.03171    0.17188
                                                          t value Pr(>|t|)    
(Intercept)                                                -1.543 0.122894    
Z                                                           5.723 1.07e-08 ***
D                                                           1.041 0.298045    
X_minus                                                    37.687  < 2e-16 ***
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)1      NaN      NaN    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)2    0.835 0.403554    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)3   -0.581 0.561267    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)4   -0.765 0.444363    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)5    0.786 0.432042    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)6   -0.399 0.689765    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)7    0.925 0.355009    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)8   -1.365 0.172273    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)9    1.355 0.175292    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)10  -0.341 0.733452    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)11   0.199 0.842456    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)12  -0.676 0.499124    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)13  -0.255 0.798831    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)14  -0.916 0.359589    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)15  -0.170 0.864712    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)16  -0.416 0.677768    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)17  -0.479 0.631776    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)18  -0.963 0.335610    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)19  -0.953 0.340492    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)20  -1.802 0.071528 .  
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)21  -0.964 0.335283    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)22  -1.596 0.110483    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)23  -0.693 0.488391    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)24  -1.077 0.281423    
bs(K_0, knots = seq(0, 1, by = 0.05), intercept = TRUE)25  -0.614 0.539108    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)1      NaN      NaN    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)2    1.482 0.138281    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)3    1.830 0.067242 .  
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)4    2.896 0.003793 ** 
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)5    3.347 0.000821 ***
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)6    0.376 0.706869    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)7    1.102 0.270557    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)8    1.024 0.305761    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)9    0.710 0.477550    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)10   0.048 0.962095    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)11  -1.498 0.134255    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)12   0.605 0.545427    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)13  -1.560 0.118711    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)14  -1.634 0.102248    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)15  -2.568 0.010251 *  
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)16  -4.424 9.80e-06 ***
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)17  -0.246 0.805775    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)18  -6.179 6.68e-10 ***
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)19  -5.402 6.73e-08 ***
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)20  -5.264 1.44e-07 ***
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)21  -7.307 2.95e-13 ***
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)22  -5.961 2.59e-09 ***
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)23  -5.628 1.87e-08 ***
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)24  -1.014 0.310389    
bs(K_1, knots = seq(0, 1, by = 0.05), intercept = TRUE)25   1.103 0.270094    
Z:D                                                         6.003 2.01e-09 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1


Rank: 51/55
R-sq.(adj) =  0.674   Deviance explained = 67.6%
GCV = 1.7758  Scale est. = 1.7667    n = 10000
> print(theoretical.values(simulated.data))
$average_first_stage
[1] 0.6488

$average_total_effect
[1] 2.570686

$average_direct_effect
[1] 1.4463

$average_indirect_effect
[1] 1.128786

> print(estimated.values(cf_firststage.reg, cf_secondstage.reg, simulated.data))
$`first-stage`
[1] 0.6467769

$`direct-effect`
[1] 1.256208

$`indirect-effect`
[1] 2.509607

> 
> #! Test, add on the K_0 and K_1 conditional on D_i = 0,1 respectively in truth
> firststage.est <- predict(
+     true_firststage.reg, newdata = mutate(simulated.data, Z = 1), type = "response") - predict(
+         true_firststage.reg, newdata = mutate(simulated.data, Z = 0), type = "response")
> # calculate the second-stage indirect effect
> indirect.est <- predict(
+     true_secondstage.reg, newdata = mutate(simulated.data, D = 1)) -
+     predict(true_secondstage.reg, newdata = mutate(simulated.data, D = 0))
> add.term <- weighted.mean(simulated.data$U_1 - simulated.data$U_0,
+     simulated.data$D_0 == 0 & simulated.data$D_1 == 1)
> mean(firststage.est * (indirect.est + add.term))
[1] 1.12739
> print(theoretical.values(simulated.data))
$average_first_stage
[1] 0.6488

$average_total_effect
[1] 2.570686

$average_direct_effect
[1] 1.4463

$average_indirect_effect
[1] 1.128786

> 
> #! Do the same thing, but kappa weighted to the compliers inside the CF estimate.
> # Estimate the kappa-weight
> hat_probZ <- lm(Z ~ 1 * X_IV * bs(X_minus, df = 10, intercept = TRUE),
+     data = simulated.data)$fitted
> kappa_1 <- simulated.data$D * ((simulated.data$Z - hat_probZ) / (
+     (1 - hat_probZ) * hat_probZ))
> kappa_0 <- (1 - simulated.data$D) * (((1 - simulated.data$Z) - (1 - hat_probZ)) / (
+     (1 - hat_probZ) * hat_probZ))
> kappa.weight <- kappa_1 * hat_probZ + kappa_0 * (1 - hat_probZ)
> # Calculate the term to add on.
> errors <- predict(cf_secondstage.reg, newdata = mutate(simulated.data,
+     Z = 0, D = 0, X_minus = 0))
> add.term <- weighted.mean(errors, simulated.data$D * kappa.weight) -
+     weighted.mean(errors, (1 - simulated.data$D) * kappa.weight)
> add.term <- weighted.mean(simulated.data$D * errors -
+     (1 - simulated.data$D) * errors, kappa.weight)
> mean(firststage.est * (indirect.est + add.term))
[1] 0.3759704
> 
> #! Test: show the ADE given Z_i = 1, and similar for AIE
> firststage.est <- predict(
+     true_firststage.reg, newdata = mutate(simulated.data, Z = 1), type = "response") - predict(
+         true_firststage.reg, newdata = mutate(simulated.data, Z = 0), type = "response")
> # calculate the second-stage direct effect
> direct.est <- predict(
+     true_secondstage.reg, newdata = mutate(simulated.data, Z = 1)) -
+     predict(true_secondstage.reg, newdata = mutate(simulated.data, Z = 0))
> # calculate the second-stage indirect effect
> indirect.est <- predict(
+     true_secondstage.reg, newdata = mutate(simulated.data, D = 1)) -
+     predict(true_secondstage.reg, newdata = mutate(simulated.data, D = 0))
> # Return the mean estimates.
> print(theoretical.values(simulated.data))
$average_first_stage
[1] 0.6488

$average_total_effect
[1] 2.570686

$average_direct_effect
[1] 1.4463

$average_indirect_effect
[1] 1.128786

> print(c("first-stage",     mean(firststage.est)))
[1] "first-stage"       "0.646906166507537"
> print(c("direct-effect",   mean(direct.est)))
[1] "direct-effect"    "1.44629999999995"
> print(c("indirect-effect", mean(firststage.est * indirect.est)))
[1] "indirect-effect"   "0.974451528746714"
> # Get the treated versions
> Z <- simulated.data$Z
> D <- simulated.data$D
> Y <- simulated.data$Y
> D_0 <- simulated.data$D_0
> D_1 <- simulated.data$D_1
> Y_0_0 <- simulated.data$Y_0_0
> Y_0_1 <- simulated.data$Y_0_1
> Y_1_0 <- simulated.data$Y_1_0
> Y_1_1 <- simulated.data$Y_1_1
> # AIE, estimae vs the group differences term.
> print(c("indirect-effect", mean(firststage.est * indirect.est)))
[1] "indirect-effect"   "0.974451528746714"
> indirect_effect <- (Z * (Y_1_1 - Y_1_0) + (1 - Z) * (Y_0_1 - Y_0_0))
> print(mean(indirect_effect * (D_1 != D_0)))
[1] 1.128786
> print(mean(indirect_effect * mean(D_1 != D_0)))
[1] 0.9883193
> print(estimated.values(true_firststage.reg, true_secondstage.reg, simulated.data)$`indirect-effect`)
[1] 0.9744515
> 
> # ADE, estimate vs group differences term.
> print(c("direct-effect",   mean(direct.est)))
[1] "direct-effect"    "1.44629999999995"
> direct_effect <- (D * (Y_1_1 - Y_0_1) + (1 - D) * (Y_1_0 - Y_0_0))
> print(mean(direct_effect))
[1] 1.4463
> print(mean(direct_effect[Z == 1]))
[1] 1.764103
> 
> #! Test: note the difference between AIE and LAIE (i.e., group differences term).
> # show gains to D, on average
> print(mean(simulated.data$Z * (simulated.data$Y_1_1 - simulated.data$Y_1_0) +
+     (1 - simulated.data$Z) * (simulated.data$Y_0_1 - simulated.data$Y_0_0)))
[1] 1.523304
> # show gains to D, among compliers
> print(mean((simulated.data$Z * (simulated.data$Y_1_1 - simulated.data$Y_1_0) +
+     (1 - simulated.data$Z) * (simulated.data$Y_0_1 - simulated.data$Y_0_0)) * (
+         simulated.data$D_1 == 1 & simulated.data$D_0 == 0)))
[1] 1.128786
> 
> #! Test, get compliers correct
> #! -> needs a different weighting scheme
> #! -> Abadie (2003) kappa weights do not get it correct.
> library(mgcv)
> cf_firststage.reg <- lm(D ~ (1 + Z) * X_IV * bs(X_minus, df = 20, intercept = TRUE),
+     data = simulated.data)
> complier.weights <- predict(
+     cf_firststage.reg, newdata = mutate(simulated.data, Z = 1), type = "response") - predict(
+         cf_firststage.reg, newdata = mutate(simulated.data, Z = 0), type = "response")
> complier.weights[complier.weights < 0] <- 0
> complier_secondstage.reg <- lm(Y ~ (1 + Z * D) + X_minus +
+     bs(K, knots = seq(-1, 1, by = 0.05)),
+     weights = complier.weights,
+     data = simulated.data)
> print(theoretical.values(simulated.data))
$average_first_stage
[1] 0.6488

$average_total_effect
[1] 2.570686

$average_direct_effect
[1] 1.4463

$average_indirect_effect
[1] 1.128786

> print(estimated.values(cf_firststage.reg, complier_secondstage.reg, simulated.data))
$`first-stage`
[1] 0.6467769

$`direct-effect`
[1] 1.215926

$`indirect-effect`
[1] 2.07287

Warning messages:
1: In predict.lm(secondstage.reg, newdata = mutate(example.data, Z = 1)) :
  prediction from rank-deficient fit; attr(*, "non-estim") has doubtful cases
2: In predict.lm(secondstage.reg, newdata = mutate(example.data, Z = 0)) :
  prediction from rank-deficient fit; attr(*, "non-estim") has doubtful cases
3: In predict.lm(secondstage.reg, newdata = mutate(example.data, D = 1)) :
  prediction from rank-deficient fit; attr(*, "non-estim") has doubtful cases
4: In predict.lm(secondstage.reg, newdata = mutate(example.data, D = 0)) :
  prediction from rank-deficient fit; attr(*, "non-estim") has doubtful cases
> 
> #! Test: including the K_0 and K_1 terms in complier gains
> simulated.data$K_0 <- (1 - simulated.data$D) * (1 - cf_firststage.reg$residuals)
> simulated.data$K_1 <- simulated.data$D * cf_firststage.reg$residuals
> complier_secondstage.reg <- lm(Y ~ (1 + Z * D) + X_minus +
+     bs(K_0, knots = seq(-0.05, 1.05, by = 0.05)) +
+     bs(K_1, knots = seq(-0.05, 1.05, by = 0.05)),
+     data = simulated.data)
> 
> # Get the returns estimate correct.
> print(mean((simulated.data$Y_0_1 - simulated.data$Y_0_0)[
+         simulated.data$Z == 0]))
[1] 1.025855
> print(mean((simulated.data$Y_0_1 - simulated.data$Y_0_0)[
+         simulated.data$Z == 0 & simulated.data$D_1 == 1 & simulated.data$D_0 == 0]))
[1] 1.223759
> print(mean((predict(
+     cf_firststage.reg, newdata = mutate(simulated.data, Z = 1), type = "response") - predict(
+         cf_firststage.reg, newdata = mutate(simulated.data, Z = 0), type = "response")) * (
+     predict(complier_secondstage.reg,
+         newdata = mutate(simulated.data, Z = 0, D = 1, K_0 = 0, K_1 = K_1)) -
+     predict(complier_secondstage.reg,
+         newdata = mutate(simulated.data, Z = 0, D = 0, K_0 = K_0, K_1 = 0)))))
[1] 1.035408
Warning message:
In predict.lm(complier_secondstage.reg, newdata = mutate(simulated.data,  :
  prediction from rank-deficient fit; attr(*, "non-estim") has doubtful cases
> print(mean(predict(complier_secondstage.reg,
+         newdata = mutate(simulated.data, Z = 0, D = 1, K_0 = 0, K_1 = 0)) -
+     predict(complier_secondstage.reg,
+         newdata = mutate(simulated.data, Z = 0, D = 0, K_0 = 0, K_1 = 0))))
[1] 1.300764
Warning message:
In predict.lm(complier_secondstage.reg, newdata = mutate(simulated.data,  :
  prediction from rank-deficient fit; attr(*, "non-estim") has doubtful cases
> 
> # calculate the second-stage indirect effect
> firststage.est <- predict(
+     cf_firststage.reg, newdata = mutate(simulated.data, Z = 1), type = "response") - predict(
+         cf_firststage.reg, newdata = mutate(simulated.data, Z = 0), type = "response")
> indirect.est <- predict(
+     complier_secondstage.reg, newdata = mutate(simulated.data, D = 1, K_0 = 0)) -
+         predict(complier_secondstage.reg, newdata = mutate(simulated.data, D = 0, K_1 = 0))
Warning message:
In predict.lm(complier_secondstage.reg, newdata = mutate(simulated.data,  :
  prediction from rank-deficient fit; attr(*, "non-estim") has doubtful cases
> direct.est <- predict(
+     complier_secondstage.reg, newdata = mutate(simulated.data, Z = 1)) -
+         predict(complier_secondstage.reg, newdata = mutate(simulated.data, Z = 0))
> # Show the means
> print(theoretical.values(simulated.data))
$average_first_stage
[1] 0.6488

$average_total_effect
[1] 2.570686

$average_direct_effect
[1] 1.4463

$average_indirect_effect
[1] 1.128786

> print(mean(direct.est))
[1] 1.262506
> print(mean(firststage.est * indirect.est))
[1] 1.374993
> # Compared the un-weighted version (which has group differences bias).
> print(estimated.values(cf_firststage.reg, complier_secondstage.reg, simulated.data))
$`first-stage`
[1] 0.6467769

$`direct-effect`
[1] 1.262506

$`indirect-effect`
[1] 1.180889

Warning messages:
1: In predict.lm(secondstage.reg, newdata = mutate(example.data, D = 1)) :
  prediction from rank-deficient fit; attr(*, "non-estim") has doubtful cases
2: In predict.lm(secondstage.reg, newdata = mutate(example.data, D = 0)) :
  prediction from rank-deficient fit; attr(*, "non-estim") has doubtful cases
> print(estimated.values(cf_firststage.reg, cf_secondstage.reg, simulated.data))
$`first-stage`
[1] 0.6467769

$`direct-effect`
[1] 1.256208

$`indirect-effect`
[1] 2.509607

There were 50 or more warnings (use warnings() to see the first 50)
> 
> 
> ################################################################################
> ## Plot bootstrap results for one DGP
> 
> # Base data to test out.
> simulated.data <- simulate.data(0.5, 1, 2, 0.25)
> 
> # Get bootstrapped point est for the CF approach
> boot.reps <- 10^2
> boot.est <- estimated.loop(boot.reps, simulated.data, bootstrap = FALSE)
[1] "1 out of 100, 1% done."
[1] "2 out of 100, 2% done."
[1] "3 out of 100, 3% done."
[1] "4 out of 100, 4% done."
[1] "5 out of 100, 5% done."
[1] "6 out of 100, 6% done."
[1] "8 out of 100, 8% done."
[1] "9 out of 100, 9% done."
[1] "10 out of 100, 10% done."
[1] "11 out of 100, 11% done."
[1] "12 out of 100, 12% done."
[1] "13 out of 100, 13% done."
[1] "15 out of 100, 15% done."
[1] "16 out of 100, 16% done."
[1] "17 out of 100, 17% done."
[1] "18 out of 100, 18% done."
[1] "19 out of 100, 19% done."
[1] "20 out of 100, 20% done."
[1] "21 out of 100, 21% done."
[1] "22 out of 100, 22% done."
[1] "23 out of 100, 23% done."
[1] "24 out of 100, 24% done."
[1] "25 out of 100, 25% done."
[1] "26 out of 100, 26% done."
[1] "27 out of 100, 27% done."
[1] "30 out of 100, 30% done."
[1] "31 out of 100, 31% done."
[1] "32 out of 100, 32% done."
[1] "33 out of 100, 33% done."
[1] "34 out of 100, 34% done."
[1] "35 out of 100, 35% done."
[1] "36 out of 100, 36% done."
[1] "37 out of 100, 37% done."
[1] "38 out of 100, 38% done."
[1] "39 out of 100, 39% done."
[1] "40 out of 100, 40% done."
[1] "41 out of 100, 41% done."
[1] "42 out of 100, 42% done."
[1] "43 out of 100, 43% done."
[1] "44 out of 100, 44% done."
[1] "45 out of 100, 45% done."
[1] "46 out of 100, 46% done."
[1] "47 out of 100, 47% done."
[1] "48 out of 100, 48% done."
[1] "49 out of 100, 49% done."
[1] "50 out of 100, 50% done."
[1] "51 out of 100, 51% done."
[1] "52 out of 100, 52% done."
[1] "53 out of 100, 53% done."
[1] "54 out of 100, 54% done."
[1] "59 out of 100, 59% done."
[1] "60 out of 100, 60% done."
[1] "61 out of 100, 61% done."
[1] "62 out of 100, 62% done."
[1] "63 out of 100, 63% done."
[1] "64 out of 100, 64% done."
[1] "65 out of 100, 65% done."
[1] "66 out of 100, 66% done."
[1] "67 out of 100, 67% done."
[1] "68 out of 100, 68% done."
[1] "69 out of 100, 69% done."
[1] "70 out of 100, 70% done."
[1] "71 out of 100, 71% done."
[1] "72 out of 100, 72% done."
[1] "73 out of 100, 73% done."
[1] "74 out of 100, 74% done."
[1] "75 out of 100, 75% done."
[1] "76 out of 100, 76% done."
[1] "77 out of 100, 77% done."
[1] "78 out of 100, 78% done."
[1] "79 out of 100, 79% done."
[1] "80 out of 100, 80% done."
[1] "81 out of 100, 81% done."
[1] "82 out of 100, 82% done."
[1] "83 out of 100, 83% done."
[1] "84 out of 100, 84% done."
[1] "85 out of 100, 85% done."
[1] "86 out of 100, 86% done."
[1] "87 out of 100, 87% done."
[1] "88 out of 100, 88% done."
[1] "89 out of 100, 89% done."
[1] "90 out of 100, 90% done."
[1] "91 out of 100, 91% done."
[1] "92 out of 100, 92% done."
[1] "93 out of 100, 93% done."
[1] "94 out of 100, 94% done."
[1] "95 out of 100, 95% done."
[1] "96 out of 100, 96% done."
[1] "97 out of 100, 97% done."
[1] "98 out of 100, 98% done."
[1] "99 out of 100, 99% done."
[1] "100 out of 100, 100% done."
There were 50 or more warnings (use warnings() to see the first 50)
> boot.data <- boot.est$data
> View(boot.data)
> 
> ## Save the bootstrapped point estimates data.
> boot.data %>% write_csv(file.path(output.folder, "boot-sim-data.csv"))
> exit.
Error: object 'exit.' not found
Execution halted
