
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> #!/usr/bin/R
> ## Senan Hogan-Hennessy, 16 Jan 2025
> ## Simulate the system for indirect + direct effects, with Roy selection.
> # Show the date:
> print(format(Sys.time(), "%H:%M %Z %A, %d %B %Y"))
[1] "09:40 EST Thursday, 30 January 2025"
> 
> ## Load libraries
> # Functions for data manipulation and visualisation
> library(tidyverse)
── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──
✔ dplyr     1.1.4     ✔ readr     2.1.5
✔ forcats   1.0.0     ✔ stringr   1.5.1
✔ ggplot2   3.5.1     ✔ tibble    3.2.1
✔ lubridate 1.9.3     ✔ tidyr     1.3.1
✔ purrr     1.0.2     
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors
> # Library for better colour choice.
> library(ggthemes)
> # Library for equations in plots
> library(latex2exp)
> # Causal medation package, Imai Keele Yamamoto (2010)
> library(mediation)
Loading required package: MASS

Attaching package: ‘MASS’

The following object is masked from ‘package:dplyr’:

    select

Loading required package: Matrix

Attaching package: ‘Matrix’

The following objects are masked from ‘package:tidyr’:

    expand, pack, unpack

Loading required package: mvtnorm
Loading required package: sandwich
mediation: Causal Mediation Analysis
Version: 4.5.0

> # Package for classical selection estimators (i.e., MLE)
> library(sampleSelection)
Loading required package: maxLik
Loading required package: miscTools

Please cite the 'maxLik' package as:
Henningsen, Arne and Toomet, Ott (2011). maxLik: A package for maximum likelihood estimation in R. Computational Statistics 26(3), 443-458. DOI 10.1007/s00180-010-0217-1.

If you have questions, suggestions, or comments regarding the 'maxLik' package, please use a forum or 'tracker' at maxLik's R-Forge site:
https://r-forge.r-project.org/projects/maxlik/
> # Package for semi-parametric regressor
> library(splines)
> 
> ## Set up the R environment
> set.seed(47)
> # Define number of digits in tables and graphs
> digits.no <- 3
> # Define where output files go.
> output.folder <- file.path("sim-output")
> # Set the options for the plot sizes, in saving ggplot output.
> fig.height <- 10
> fig.width <- fig.height
> 
> # Define the sample size to work with.
> sample.N <- 10^4
> 
> 
> ################################################################################
> ## Define a function to simulate data in the triangular system.
> 
> # Define a function to simulate all observed + unobserved data 
> simulate.data <- function(rho, sigma_0, sigma_1, sigma_C,
+         sample.size = sample.N){
+     ### Inputs:
+     ## X, a matrix of covariates, continuous or binary values.
+     ## rho \in [-1, +1] measuring correlation between U_0, U_1.
+     ## sigma_0 >= 0 measuring standard deviation of U_0.
+     ## sigma_1 >= 0 measuring standard deviation of U_1.
+     ## sigma_C >= 0 measuring standard deviation of U_C.
+     ## sample.size: integer, representing output sample size i.e., N.
+     # First covariate (\vec X_i^-)
+     X_minus <- 4 + rnorm(sample.size, mean = 0, sd = 1)
+     # Second covariate (instrument for the control function).
+     X_IV <- rbinom(sample.size, 1, 1 / 2)
+     # Simulate the unobserved error terms.
+     U_both <- MASS::mvrnorm(
+         n = sample.size,
+         mu = c(0, 0, 0),
+         Sigma = matrix(c(
+             sigma_0^2,                rho * sigma_0 * sigma_1,  0,
+             rho * sigma_0 * sigma_1,  sigma_1^2,                0,
+             0,                        0,                        sigma_C^2), ncol = 3),
+         empirical = FALSE)
+     U_0 <- U_both[, 1]
+     U_1 <- U_both[, 2]
+     U_C <- U_both[, 3]
+     # Define the mean potential outcomes.
+     mu_outcome_z_d_X <- function(z, d, x_minus){
+         return(x_minus + (z + d + z * d))
+     }
+     mu_cost_z_X <- function(z, x_minus, x_iv){
+         return(- 3 * z + x_minus - x_iv)
+     }
+     # Y_i(Z, D) = mu_D(Z; X_i) + U_D
+     Y_0_0 <- mu_outcome_z_d_X(0, 0, X_minus) + U_0
+     Y_0_1 <- mu_outcome_z_d_X(0, 1, X_minus) + U_1
+     Y_1_0 <- mu_outcome_z_d_X(1, 0, X_minus) + U_0
+     Y_1_1 <- mu_outcome_z_d_X(1, 1, X_minus) + U_1
+     # D_i(Z)= 1{ Y(Z, 1) - Y(Z, 0) >= C_i }
+     D_0 <- as.integer(Y_0_1 - Y_0_0 >= mu_cost_z_X(0, X_minus, X_IV) + U_C)
+     D_1 <- as.integer(Y_1_1 - Y_1_0 >= mu_cost_z_X(1, X_minus, X_IV) + U_C)
+     # Generate the individual effects (direct + indirect)
+     probZ <- 0.5
+     Z <- rbinom(sample.size, 1, probZ)
+     # Observed outcomes: D, Y
+     D <- (Z * D_1) + ((1 - Z) * D_0)
+     # Generate the list of observed outcomes
+     Y <- (Z * D * Y_1_1) +
+         (Z * (1 - D) * Y_1_0) +
+         ((1 - Z) * D * Y_0_1) +
+         ((1 - Z) * (1 - D) * Y_0_0)
+     # Put these data to a coherent data frame.
+     combined.data <- data.frame(
+         # Observed data
+         Z, D, Y,  X_minus, X_IV,
+         # Unobserved, potential outcomes and compliance.
+         D_0, D_1,
+         Y_0_0, Y_0_1, Y_1_0, Y_1_1,
+         #mu0_Z0_X, mu1_Z0_X, mu0_Z1_X, mu1_Z1_X, muC_Z0_X, muC_Z1_X, 
+         U_0, U_1, U_C)
+     # Return the simulated data as a data frame.
+     return(combined.data)
+ }
> 
> 
> ################################################################################
> ## Define a function to show the theoretical values for the data.
> theoretical.values <- function(sim.data, digits.no = 3, print.compliers = FALSE){
+     ### Inputs:
+     ## sim.data, a data frame simulated from above.
+     # Extract the potentials from simulated data.
+     Z <- sim.data$Z
+     D <- sim.data$D
+     Y <- sim.data$Y
+     X_minus <- sim.data$X_minus
+     X_IV <- sim.data$X_IV
+     D_0 <- sim.data$D_0
+     D_1 <- sim.data$D_1
+     Y_0_0 <- sim.data$Y_0_0
+     Y_0_1 <- sim.data$Y_0_1
+     Y_1_0 <- sim.data$Y_1_0
+     Y_1_1 <- sim.data$Y_1_1
+     U_0 <- sim.data$U_0
+     U_1 <- sim.data$U_1
+     U_C <- sim.data$U_C
+     # Get the true first-stage effects
+     first_stage <- D_1 - D_0
+     average_first_stage <- mean(first_stage)
+     # Show how many ATs, NTs, Compliers in terms of D_i(Z) for Z = 0, 1.
+     if (print.compliers == TRUE){
+         print("How many compliers in the sample?")
+         print(table(D_1, D_0) / NROW(sim.data))
+     }
+     # Get the theoretical total effect/reduced form/ITT
+     total_effect <-
+         (Y_1_1 - Y_0_0) * (D_1 == 1 & D_0 == 0) +
+         (Y_1_1 - Y_0_1) * (D_1 == 1 & D_0 == 1) +
+         (Y_1_0 - Y_0_0) * (D_1 == 0 & D_0 == 0)
+     average_total_effect <- mean(total_effect)
+     # Get the theoretical indirect effect.
+     indirect_effect <-
+         (Z * (Y_1_1 - Y_1_0) + (1 - Z) * (Y_0_1 - Y_0_0)) * (D_1 == 1 & D_0 == 0)
+     average_indirect_effect <- mean(indirect_effect)
+     # Get the theoretical direct effect.
+     direct_effect <- #(D * (Y_1_1 - Y_0_1) + (1 - D) * (Y_1_0 - Y_0_0))
+         (D * (Y_1_1 - Y_0_1) + (1 - D) * (Y_1_0 - Y_0_0)) * (D_1 == 1 & D_0 == 0) +
+         (Y_1_1 - Y_0_1) * (D_1 == 1 & D_0 == 1) +
+         (Y_1_0 - Y_0_0) * (D_1 == 0 & D_0 == 0)
+     average_direct_effect <- mean(direct_effect)
+     # Define a named list to return
+     output.list <- list(
+         average_first_stage     = average_first_stage,
+         average_total_effect    = average_total_effect,
+         average_direct_effect   = average_direct_effect,
+         average_indirect_effect = average_indirect_effect)
+     # Return the output.list
+     return(output.list)
+ }
> 
> ################################################################################
> ## Define a function to estimate mediation, given the first + second-stages.
> 
> # Estimate the values, given a first and second-stages
> estimated.values <- function(firststage.reg, secondstage.reg, example.data){
+     ### Inputs:
+     ## example.data, a data frame simulated from above.
+     # calculate the first-stage by prediction
+     firststage.est <- predict(
+         firststage.reg, newdata = mutate(example.data, Z = 1), type = "response") - predict(
+             firststage.reg, newdata = mutate(example.data, Z = 0), type = "response")
+     # calculate the second-stage direct effect
+     direct.est <- predict(
+         secondstage.reg, newdata = mutate(example.data, Z = 1)) -
+         predict(secondstage.reg, newdata = mutate(example.data, Z = 0))
+     # calculate the second-stage indirect effect
+     indirect.est <- predict(
+         secondstage.reg, newdata = mutate(example.data, D = 1)) -#, K_0 = 0)) -
+         predict(secondstage.reg, newdata = mutate(example.data, D = 0))#, K_1 = 0))
+     # Return the mean estimates.
+     output.list <- list(
+         "first-stage"     = mean(firststage.est),
+         "direct-effect"   = mean(direct.est),
+         "indirect-effect" = mean(firststage.est * indirect.est))
+     # Return the output.list
+ }
> 
> # Bootstrap the estimates.
> estimated.bootstrap <- function(boot.reps, example.data,
+         sample.size = sample.N, print.progress = TRUE){
+     # Define lists the will be returned:
+     # 2. Naive OLS.
+     ols_direct_effect <- c()
+     ols_indirect_effect <- c()
+     # 3. Control function.
+     cf_direct_effect <- c()
+     cf_indirect_effect <- c()
+     # More in the future ....
+     ## Loop across the bootstraps values.
+     for (i in seq(1, boot.reps)){
+         # Print on whole percentage values
+         if (print.progress & ((100 * (i / boot.reps)) %% 1) == 0) {
+             print(paste0(i, " out of ", boot.reps, ", ", 100 * (i / boot.reps), "% done."))
+         }
+         # Draw a bootstrap sample from data
+         boot.indicies <- sample(seq(1, sample.size), sample.size, replace = TRUE)
+         boot.data <- example.data[boot.indicies, ]
+         # Calculate the truth values, given the simulated data
+         truth.est <- theoretical.values(example.data)
+         # Now get the mediation effects, by different approaches.
+         # 2. OLS estimate of second-stage
+         ols_firststage.reg <- lm(D ~ (1 + Z) + X_minus + X_IV, data = boot.data)
+         ols_secondstage.reg <- lm(Y ~ 1 + Z * D + X_minus, data = boot.data)
+         ols.est <- estimated.values(ols_firststage.reg, ols_secondstage.reg, boot.data)
+         # 3. Control Function estimates.
+         cf_firststage.reg <- lm(D ~ (1 + Z) * X_IV *
+             bs(X_minus, df = 20, intercept = TRUE),
+             data = boot.data)
+         boot.data$K_0 <- (1 - boot.data$D) * cf_firststage.reg$residuals
+         boot.data$K_1 <- boot.data$D * cf_firststage.reg$residuals
+         cf_secondstage.reg <- lm(
+             Y ~ (1 + Z * D) + X_minus +
+             bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE) +
+             bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE),
+             #bs(K, knots = seq(-1, 1, by = 0.025), intercept = TRUE),
+             data = boot.data)
+         cf.est <- estimated.values(cf_firststage.reg, cf_secondstage.reg, boot.data)
+         # Save the outputs.
+         ols_direct_effect[i]     <- ols.est$`direct-effect`
+         ols_indirect_effect[i]   <- ols.est$`indirect-effect`
+         cf_direct_effect[i]      <- cf.est$`direct-effect`
+         cf_indirect_effect[i]    <- cf.est$`indirect-effect`
+     }
+     # Return the bootstrap data.
+     output.list <- list()
+     output.list$data <- data.frame(
+         truth_direct_effect   = as.numeric(truth.est$average_direct_effect),
+         ols_direct_effect     = ols_direct_effect,
+         cf_direct_effect      = cf_direct_effect,
+         truth_indirect_effect = as.numeric(truth.est$average_indirect_effect),
+         ols_indirect_effect   = ols_indirect_effect,
+         cf_indirect_effect    = cf_indirect_effect
+     )
+     # Calculate the needed statistics, to return
+     output.list$estimates <- data.frame(
+         # Truth
+         truth_direct_effect     = as.numeric(truth.est$average_direct_effect),
+         truth_indirect_effect   = as.numeric(truth.est$average_indirect_effect),
+         # OLS mean, and the 95% confidence intervals
+         ols_direct_effect       = as.numeric(mean(ols_direct_effect)),
+         ols_direct_effect_se    = as.numeric(sd(ols_direct_effect)),
+         ols_direct_effect_up    = as.numeric(quantile(ols_direct_effect, probs = 0.975)),
+         ols_direct_effect_low   = as.numeric(quantile(ols_direct_effect, probs = 0.025)),
+         ols_indirect_effect     = as.numeric(mean(ols_indirect_effect)),
+         ols_indirect_effect_se  = as.numeric(sd(ols_indirect_effect)),
+         ols_indirect_effect_up  = as.numeric(quantile(ols_indirect_effect, probs = 0.975)),
+         ols_indirect_effect_low = as.numeric(quantile(ols_indirect_effect, probs = 0.025)),
+         # Control Fun mean, and the 95% confidence intervals
+         cf_direct_effect        = as.numeric(mean(cf_direct_effect)),
+         cf_direct_effect_se     = as.numeric(sd(cf_direct_effect)),
+         cf_direct_effect_up     = as.numeric(quantile(cf_direct_effect, probs = 0.975)),
+         cf_direct_effect_low    = as.numeric(quantile(cf_direct_effect, probs = 0.025)),
+         cf_indirect_effect      = as.numeric(mean(cf_indirect_effect)),
+         cf_indirect_effect_se   = as.numeric(sd(cf_indirect_effect)),
+         cf_indirect_effect_up   = as.numeric(quantile(cf_indirect_effect, probs = 0.975)),
+         cf_indirect_effect_low  = as.numeric(quantile(cf_indirect_effect, probs = 0.025))
+     )
+     return(output.list)
+ }
> 
> 
> ################################################################################
> ## Compare estimation methods, in one simulation.
> 
> ## Simulate the data: rho, sigma_0, sigma_1, sigma_C = 0.5, 1, 2, 1.
> simulated.data <- simulate.data(0.5, 1, 2, 0.25)
> # SHow the theoretical direct + indirect values
> print(theoretical.values(simulated.data, print.compliers = TRUE))
[1] "How many compliers in the sample?"
   D_0
D_1      0      1
  0 0.2298 0.0000
  1 0.6529 0.1173
$average_first_stage
[1] 0.6529

$average_total_effect
[1] 2.584529

$average_direct_effect
[1] 1.437

$average_indirect_effect
[1] 1.134029

> 
> # Show that the regression specification holds exactly (after debiasing outcome).
> true_firststage.reg <- glm(D ~ (1 + Z) + X_IV + bs(X_minus, df = 5, intercept = TRUE),
+     family = binomial(link = "probit"), data = simulated.data)
> simulated.data$K_0 <- (1 - simulated.data$D) * simulated.data$U_0
> simulated.data$K_1 <- simulated.data$D * simulated.data$U_1
> true_secondstage.reg <- lm(Y ~ (1 + Z * D) + X_minus + K_0 + K_1,
+     data = simulated.data)
> print(theoretical.values(simulated.data))
$average_first_stage
[1] 0.6529

$average_total_effect
[1] 2.584529

$average_direct_effect
[1] 1.437

$average_indirect_effect
[1] 1.134029

> print(estimated.values(true_firststage.reg, true_secondstage.reg, simulated.data))
$`first-stage`
[1] 0.6542521

$`direct-effect`
[1] 1.437

$`indirect-effect`
[1] 0.9771183

> # This is because the truth second-stage is perfect:
> print(summary(true_secondstage.reg))

Call:
lm(formula = Y ~ (1 + Z * D) + X_minus + K_0 + K_1, data = simulated.data)

Residuals:
       Min         1Q     Median         3Q        Max 
-6.075e-12 -1.600e-15 -4.000e-16  5.000e-16  9.093e-12 

Coefficients:
             Estimate Std. Error   t value Pr(>|t|)    
(Intercept) 8.193e-14  5.100e-15 1.607e+01   <2e-16 ***
Z           1.000e+00  3.759e-15 2.660e+14   <2e-16 ***
D           1.000e+00  5.715e-15 1.750e+14   <2e-16 ***
X_minus     1.000e+00  1.175e-15 8.514e+14   <2e-16 ***
K_0         1.000e+00  1.472e-15 6.795e+14   <2e-16 ***
K_1         1.000e+00  9.932e-16 1.007e+15   <2e-16 ***
Z:D         1.000e+00  6.515e-15 1.535e+14   <2e-16 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 1.117e-13 on 9993 degrees of freedom
Multiple R-squared:      1,	Adjusted R-squared:      1 
F-statistic: 7.174e+29 on 6 and 9993 DF,  p-value: < 2.2e-16

> 
> # Show how the OLS result gives a bias result (if rho != 0)
> ols_firststage.reg <- lm(D ~ (1 + Z) + X_minus + X_IV, data = simulated.data)
> ols_secondstage.reg <- lm(Y ~ 1 + Z * D + X_minus, data = simulated.data)
> print(theoretical.values(simulated.data))
$average_first_stage
[1] 0.6529

$average_total_effect
[1] 2.584529

$average_direct_effect
[1] 1.437

$average_indirect_effect
[1] 1.134029

> print(estimated.values(ols_firststage.reg, ols_secondstage.reg, simulated.data))
$`first-stage`
[1] 0.6540601

$`direct-effect`
[1] 0.4654462

$`indirect-effect`
[1] 2.126994

> 
> # Show how (unknown) control function gets it correct, in 2 steps (with splines)
> cf_firststage.reg <- lm(D ~ (1 + Z) * X_IV * bs(X_minus, df = 20, intercept = TRUE),
+     data = simulated.data)
> simulated.data$K <- cf_firststage.reg$residuals
> simulated.data$K_0 <- (1 - simulated.data$D) * cf_firststage.reg$residuals
> simulated.data$K_1 <- simulated.data$D * cf_firststage.reg$residuals
> cf_secondstage.reg <- lm(Y ~ (1 + Z * D) + X_minus +
+     bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE) +
+     bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE),
+     #bs(K, knots = seq(-1, 1, by = 0.025), intercept = TRUE),
+     data = simulated.data)
> print(summary(cf_secondstage.reg))

Call:
lm(formula = Y ~ (1 + Z * D) + X_minus + bs(K_0, knots = seq(0, 
    1, by = 0.025), intercept = FALSE) + bs(K_1, knots = seq(0, 
    1, by = 0.025), intercept = FALSE), data = simulated.data)

Residuals:
    Min      1Q  Median      3Q     Max 
-5.6070 -0.8433 -0.0249  0.8293  5.7340 

Coefficients: (39 not defined because of singularities)
                                                             Estimate
(Intercept)                                                   3.90291
Z                                                             0.96373
D                                                             0.94029
X_minus                                                       0.99771
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)1    0.25960
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)2   -0.21087
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)3    0.13456
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)4  -21.52877
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)5  117.80559
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)6         NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)7         NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)8         NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)9    0.86776
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)10        NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)11        NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)12        NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)13        NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)14        NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)15        NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)16        NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)17        NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)18        NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)19        NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)20        NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)21        NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)22        NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)23        NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)24        NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)25        NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)26        NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)27        NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)28        NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)29        NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)30        NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)31        NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)32        NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)33        NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)34        NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)35        NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)36        NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)37        NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)38        NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)39        NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)40        NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)41        NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)42        NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)43        NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)44        NA
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)1   10.13829
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)2   -4.86464
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)3   -3.89649
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)4   -3.56791
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)5   -3.94850
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)6   -3.69710
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)7   -3.58212
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)8   -3.42600
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)9   -3.56814
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)10  -2.97994
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)11  -3.54769
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)12  -2.94045
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)13  -3.94663
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)14  -2.83164
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)15  -3.11326
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)16  -3.02039
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)17  -3.02877
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)18  -2.60241
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)19  -2.74887
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)20  -3.19910
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)21  -2.42681
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)22  -3.53703
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)23  -1.91741
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)24  -2.43413
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)25  -2.21109
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)26  -2.75420
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)27  -1.22759
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)28  -2.23362
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)29  -1.86901
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)30  -2.02588
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)31  -1.45336
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)32  -1.91827
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)33  -1.62885
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)34  -1.43930
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)35  -1.33267
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)36  -1.00761
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)37  -0.69921
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)38  -0.92023
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)39  -1.25580
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)40  -0.66086
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)41   1.56391
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)42  -1.58083
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)43   1.64357
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)44        NA
Z:D                                                           1.09950
                                                            Std. Error t value
(Intercept)                                                    1.35618   2.878
Z                                                              0.14448   6.670
D                                                              0.26114   3.601
X_minus                                                        0.02906  34.333
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)1     0.40501   0.641
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)2     0.19552  -1.079
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)3     0.26633   0.505
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)4    17.74009  -1.214
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)5   111.63998   1.055
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)6          NA      NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)7          NA      NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)8          NA      NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)9     1.35059   0.643
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)10         NA      NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)11         NA      NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)12         NA      NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)13         NA      NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)14         NA      NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)15         NA      NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)16         NA      NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)17         NA      NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)18         NA      NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)19         NA      NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)20         NA      NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)21         NA      NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)22         NA      NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)23         NA      NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)24         NA      NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)25         NA      NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)26         NA      NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)27         NA      NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)28         NA      NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)29         NA      NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)30         NA      NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)31         NA      NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)32         NA      NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)33         NA      NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)34         NA      NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)35         NA      NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)36         NA      NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)37         NA      NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)38         NA      NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)39         NA      NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)40         NA      NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)41         NA      NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)42         NA      NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)43         NA      NA
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)44         NA      NA
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)1     6.70021   1.513
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)2     1.57512  -3.088
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)3     1.35830  -2.869
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)4     1.35343  -2.636
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)5     1.35216  -2.920
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)6     1.35056  -2.737
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)7     1.34975  -2.654
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)8     1.35002  -2.538
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)9     1.35002  -2.643
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)10    1.36015  -2.191
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)11    1.36579  -2.598
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)12    1.37406  -2.140
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)13    1.38948  -2.840
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)14    1.36968  -2.067
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)15    1.37839  -2.259
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)16    1.38767  -2.177
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)17    1.36874  -2.213
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)18    1.38691  -1.876
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)19    1.40043  -1.963
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)20    1.40092  -2.284
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)21    1.38451  -1.753
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)22    1.42382  -2.484
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)23    1.42266  -1.348
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)24    1.43826  -1.692
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)25    1.42739  -1.549
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)26    1.44714  -1.903
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)27    1.46665  -0.837
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)28    1.47386  -1.515
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)29    1.45296  -1.286
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)30    1.45931  -1.388
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)31    1.43487  -1.013
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)32    1.41709  -1.354
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)33    1.41496  -1.151
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)34    1.39340  -1.033
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)35    1.43692  -0.927
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)36    1.40938  -0.715
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)37    1.39398  -0.502
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)38    1.41059  -0.652
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)39    1.47199  -0.853
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)40    1.46310  -0.452
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)41    1.77004   0.884
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)42    2.01678  -0.784
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)43    1.67062   0.984
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)44         NA      NA
Z:D                                                            0.17615   6.242
                                                            Pr(>|t|)    
(Intercept)                                                 0.004012 ** 
Z                                                           2.69e-11 ***
D                                                           0.000319 ***
X_minus                                                      < 2e-16 ***
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)1  0.521548    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)2  0.280835    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)3  0.613399    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)4  0.224942    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)5  0.291347    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)6        NA    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)7        NA    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)8        NA    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)9  0.520560    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)10       NA    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)11       NA    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)12       NA    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)13       NA    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)14       NA    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)15       NA    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)16       NA    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)17       NA    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)18       NA    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)19       NA    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)20       NA    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)21       NA    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)22       NA    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)23       NA    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)24       NA    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)25       NA    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)26       NA    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)27       NA    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)28       NA    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)29       NA    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)30       NA    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)31       NA    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)32       NA    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)33       NA    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)34       NA    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)35       NA    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)36       NA    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)37       NA    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)38       NA    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)39       NA    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)40       NA    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)41       NA    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)42       NA    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)43       NA    
bs(K_0, knots = seq(0, 1, by = 0.025), intercept = FALSE)44       NA    
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)1  0.130278    
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)2  0.002018 ** 
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)3  0.004131 ** 
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)4  0.008397 ** 
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)5  0.003507 ** 
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)6  0.006203 ** 
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)7  0.007969 ** 
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)8  0.011172 *  
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)9  0.008230 ** 
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)10 0.028483 *  
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)11 0.009404 ** 
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)12 0.032382 *  
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)13 0.004515 ** 
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)14 0.038725 *  
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)15 0.023928 *  
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)16 0.029535 *  
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)17 0.026933 *  
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)18 0.060628 .  
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)19 0.049688 *  
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)20 0.022418 *  
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)21 0.079663 .  
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)22 0.013001 *  
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)23 0.177764    
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)24 0.090599 .  
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)25 0.121402    
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)26 0.057044 .  
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)27 0.402611    
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)28 0.129680    
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)29 0.198352    
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)30 0.165094    
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)31 0.311140    
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)32 0.175873    
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)33 0.249693    
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)34 0.301659    
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)35 0.353716    
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)36 0.474668    
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)37 0.615968    
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)38 0.514173    
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)39 0.393608    
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)40 0.651507    
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)41 0.376964    
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)42 0.433155    
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)43 0.325233    
bs(K_1, knots = seq(0, 1, by = 0.025), intercept = FALSE)44       NA    
Z:D                                                         4.50e-10 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 1.333 on 9946 degrees of freedom
Multiple R-squared:  0.6706,	Adjusted R-squared:  0.6688 
F-statistic:   382 on 53 and 9946 DF,  p-value: < 2.2e-16

> print(theoretical.values(simulated.data))
$average_first_stage
[1] 0.6529

$average_total_effect
[1] 2.584529

$average_direct_effect
[1] 1.437

$average_indirect_effect
[1] 1.134029

> print(estimated.values(cf_firststage.reg, cf_secondstage.reg, simulated.data))
$`first-stage`
[1] 0.6541503

$`direct-effect`
[1] 1.444208

$`indirect-effect`
[1] 0.9700234

> 
> #! Test: show the ADE given Z_i = 1, and similar for AIE
> firststage.est <- predict(
+     true_firststage.reg, newdata = mutate(simulated.data, Z = 1), type = "response") - predict(
+         true_firststage.reg, newdata = mutate(simulated.data, Z = 0), type = "response")
> # calculate the second-stage direct effect
> direct.est <- predict(
+     true_secondstage.reg, newdata = mutate(simulated.data, Z = 1)) -
+     predict(true_secondstage.reg, newdata = mutate(simulated.data, Z = 0))
> # calculate the second-stage indirect effect
> indirect.est <- predict(
+     true_secondstage.reg, newdata = mutate(simulated.data, D = 1)) -
+     predict(true_secondstage.reg, newdata = mutate(simulated.data, D = 0))
> # Return the mean estimates.
> print(theoretical.values(simulated.data))
$average_first_stage
[1] 0.6529

$average_total_effect
[1] 2.584529

$average_direct_effect
[1] 1.437

$average_indirect_effect
[1] 1.134029

> print(c("first-stage",     mean(firststage.est)))
[1] "first-stage"       "0.654252051084466"
> print(c("direct-effect",   mean(direct.est)))
[1] "direct-effect"    "1.43699999999971"
> print(c("indirect-effect", mean(firststage.est * indirect.est)))
[1] "indirect-effect"   "0.977118345334095"
> # Get the treated versions
> Z <- simulated.data$Z
> D <- simulated.data$D
> Y <- simulated.data$Y
> D_0 <- simulated.data$D_0
> D_1 <- simulated.data$D_1
> Y_0_0 <- simulated.data$Y_0_0
> Y_0_1 <- simulated.data$Y_0_1
> Y_1_0 <- simulated.data$Y_1_0
> Y_1_1 <- simulated.data$Y_1_1
> # AIE, estimae vs the group differences term.
> print(c("indirect-effect", mean(firststage.est * indirect.est)))
[1] "indirect-effect"   "0.977118345334095"
> indirect_effect <- (Z * (Y_1_1 - Y_1_0) + (1 - Z) * (Y_0_1 - Y_0_0))
> print(mean(indirect_effect * (D_1 != D_0)))
[1] 1.134029
> print(mean(indirect_effect * mean(D_1 != D_0)))
[1] 0.9888216
> # ADE, estimate vs group differences term.
> print(c("direct-effect",   mean(direct.est)))
[1] "direct-effect"    "1.43699999999971"
> direct_effect <- (D * (Y_1_1 - Y_0_1) + (1 - D) * (Y_1_0 - Y_0_0))
> print(mean(direct_effect))
[1] 1.437
> print(mean(direct_effect[Z == 1]))
[1] 1.769371
> 
> #! Test: note the difference between AIE and LAIE (i.e., group differences term).
> # show gains to D, on average
> print(mean(simulated.data$Z * (simulated.data$Y_1_1 - simulated.data$Y_1_0) +
+     (1 - simulated.data$Z) * (simulated.data$Y_0_1 - simulated.data$Y_0_0)))
[1] 1.514507
> # show gains to D, among compliers
> print(mean((simulated.data$Z * (simulated.data$Y_1_1 - simulated.data$Y_1_0) +
+     (1 - simulated.data$Z) * (simulated.data$Y_0_1 - simulated.data$Y_0_0)) * (
+         simulated.data$D_1 == 1 & simulated.data$D_0 == 0)))
[1] 1.134029
> 
> #! Test, get compliers correct
> #! -> needs a different weighting scheme
> #! -> Abadie (2003) kappa weights do not get it correct.
> library(mgcv)
Loading required package: nlme

Attaching package: ‘nlme’

The following object is masked from ‘package:dplyr’:

    collapse

This is mgcv 1.9-1. For overview type 'help("mgcv-package")'.
> cf_firststage.reg <- lm(D ~ (1 + Z) * X_IV * bs(X_minus, df = 20, intercept = TRUE),
+     data = simulated.data)
> complier.weights <- predict(
+     cf_firststage.reg, newdata = mutate(simulated.data, Z = 1), type = "response") - predict(
+         cf_firststage.reg, newdata = mutate(simulated.data, Z = 0), type = "response")
> complier.weights[complier.weights < 0] <- 0
> complier_secondstage.reg <- lm(Y ~ (1 + Z * D) + X_minus +
+     bs(K, knots = seq(-1, 1, by = 0.05)),
+     weights = complier.weights,
+     data = simulated.data)
> print(theoretical.values(simulated.data))
$average_first_stage
[1] 0.6529

$average_total_effect
[1] 2.584529

$average_direct_effect
[1] 1.437

$average_indirect_effect
[1] 1.134029

> print(estimated.values(cf_firststage.reg, complier_secondstage.reg, simulated.data))
$`first-stage`
[1] 0.6541503

$`direct-effect`
[1] 1.475291

$`indirect-effect`
[1] 0.9363099

> 
> #! Test: including the K_0 and K_1 terms in complier gains
> simulated.data$K_0 <- (1 - simulated.data$D) * cf_firststage.reg$residuals
> simulated.data$K_1 <- simulated.data$D * cf_firststage.reg$residuals
> complier_secondstage.reg <- lm(Y ~ (1 + Z * D) + X_minus +
+     bs(K_0, knots = seq(-0.05, 1.05, by = 0.05)) +
+     bs(K_1, knots = seq(-0.05, 1.05, by = 0.05)),
+     data = simulated.data)
> 
> # Get the returns estimate correct.
> print(mean((simulated.data$Y_0_1 - simulated.data$Y_0_0)[
+         simulated.data$Z == 0]))
[1] 1.003902
> print(mean((simulated.data$Y_0_1 - simulated.data$Y_0_0)[
+         simulated.data$Z == 0 & simulated.data$D_1 == 1 & simulated.data$D_0 == 0]))
[1] 1.224703
> print(mean((predict(
+     cf_firststage.reg, newdata = mutate(simulated.data, Z = 1), type = "response") - predict(
+         cf_firststage.reg, newdata = mutate(simulated.data, Z = 0), type = "response")) * (
+     predict(complier_secondstage.reg,
+         newdata = mutate(simulated.data, Z = 0, D = 1, K_0 = 0, K_1 = K_1)) -
+     predict(complier_secondstage.reg,
+         newdata = mutate(simulated.data, Z = 0, D = 0, K_0 = K_0, K_1 = 0)))))
[1] 0.892786
> print(mean(predict(complier_secondstage.reg,
+         newdata = mutate(simulated.data, Z = 0, D = 1, K_0 = 0, K_1 = 0)) -
+     predict(complier_secondstage.reg,
+         newdata = mutate(simulated.data, Z = 0, D = 0, K_0 = 0, K_1 = 0))))
[1] 1.011974
> 
> # calculate the second-stage indirect effect
> firststage.est <- predict(
+     cf_firststage.reg, newdata = mutate(simulated.data, Z = 1), type = "response") - predict(
+         cf_firststage.reg, newdata = mutate(simulated.data, Z = 0), type = "response")
> indirect.est <- predict(
+     complier_secondstage.reg, newdata = mutate(simulated.data, D = 1, K_0 = 0)) -
+         predict(complier_secondstage.reg, newdata = mutate(simulated.data, D = 0, K_1 = 0))
> direct.est <- predict(
+     complier_secondstage.reg, newdata = mutate(simulated.data, Z = 1)) -
+         predict(complier_secondstage.reg, newdata = mutate(simulated.data, Z = 0))
> # Show the means
> print(theoretical.values(simulated.data))
$average_first_stage
[1] 0.6529

$average_total_effect
[1] 2.584529

$average_direct_effect
[1] 1.437

$average_indirect_effect
[1] 1.134029

> print(mean(direct.est))
[1] 1.417255
> print(mean(firststage.est * indirect.est))
[1] 1.250274
> # Compared the un-weighted version (which has group differences bias).
> print(estimated.values(cf_firststage.reg, complier_secondstage.reg, simulated.data))
$`first-stage`
[1] 0.6541503

$`direct-effect`
[1] 1.417255

$`indirect-effect`
[1] 1.019471

> print(estimated.values(cf_firststage.reg, cf_secondstage.reg, simulated.data))
$`first-stage`
[1] 0.6541503

$`direct-effect`
[1] 1.444208

$`indirect-effect`
[1] 0.9700234

> 
> 
> ################################################################################
> ## Plot bootstrap results for one DGP
> 
> # Base data to test out.
> simulated.data <- simulate.data(0.5, 1, 2, 0.25)
> 
> ## Get bootstrapped point est for the CF approach
> #boot.reps <- 10000
> #boot.est <- estimated.bootstrap(boot.reps, simulated.data, print.progress = TRUE)
> #boot.data <- boot.est$data
> #print(boot.data)
> #
> ### Save the bootstrapped point estimates data.
> #boot.data %>% write_csv(file.path(output.folder, "boot-sim-data.csv"))
> 
> 
> ################################################################################
> ## Compare estimation methods, across different sigma values.
> 
> # Define an empty dataframe, to start adding to.
> boot.values <- estimated.bootstrap(1, simulated.data)$estimates
[1] "1 out of 1, 100% done."
> boot.values$sigma <- NA
> sigma.data <- boot.values[0, ]
> print(sigma.data)
 [1] truth_direct_effect     truth_indirect_effect   ols_direct_effect      
 [4] ols_direct_effect_se    ols_direct_effect_up    ols_direct_effect_low  
 [7] ols_indirect_effect     ols_indirect_effect_se  ols_indirect_effect_up 
[10] ols_indirect_effect_low cf_direct_effect        cf_direct_effect_se    
[13] cf_direct_effect_up     cf_direct_effect_low    cf_indirect_effect     
[16] cf_indirect_effect_se   cf_indirect_effect_up   cf_indirect_effect_low 
[19] sigma                  
<0 rows> (or 0-length row.names)
> # Define values in rho \in [-1, 1] to go across
> sigma.values <- c(0, seq(0, 2, by = 0.25))
> # Define the number of boot reps for each
> boot.reps <- 1000
> i <- 0
> 
> # Start the sigma loop
> for (sigma in sigma.values){
+     # Simulate the data: rho, sigma_0, sigma_1, sigma_C
+     sigma_sim.data <- simulate.data(0.5, 1, sigma, 0.25)
+     # Get the truth + estimates + bootstrapped SEs, and save rho value
+     sigma.boot <- estimated.bootstrap(
+         boot.reps, simulated.data, print.progress = FALSE)$estimates
+     sigma.boot$sigma <- sigma
+     # Add to the dataframe.
+     sigma.data[i, ] <- sigma.boot
+     # SHow far we are.
+     i <- i + 1
+     print(paste0(sigma, " in [0, 2], ", 100 * i / length(sigma.values), "% done."))
+     gc()
+ }
[1] "0 in [0, 2], 10% done."
[1] "0 in [0, 2], 20% done."
[1] "0.25 in [0, 2], 30% done."
[1] "0.5 in [0, 2], 40% done."
[1] "0.75 in [0, 2], 50% done."
[1] "1 in [0, 2], 60% done."
[1] "1.25 in [0, 2], 70% done."
[1] "1.5 in [0, 2], 80% done."
[1] "1.75 in [0, 2], 90% done."
[1] "2 in [0, 2], 100% done."
> # Save the output data.
> sigma.data %>% write_csv(file.path(output.folder, "sigma-sim-data.csv"))
> 
> 
> ################################################################################
> ## Compare estimation methods, across different rho values.
> 
> # Define an empty dataframe, to start adding to.
> boot.values <- estimated.bootstrap(1, simulated.data)$estimates
[1] "1 out of 1, 100% done."
> boot.values$rho <- NA
> rho.data <- boot.values[0, ]
> print(rho.data)
 [1] truth_direct_effect     truth_indirect_effect   ols_direct_effect      
 [4] ols_direct_effect_se    ols_direct_effect_up    ols_direct_effect_low  
 [7] ols_indirect_effect     ols_indirect_effect_se  ols_indirect_effect_up 
[10] ols_indirect_effect_low cf_direct_effect        cf_direct_effect_se    
[13] cf_direct_effect_up     cf_direct_effect_low    cf_indirect_effect     
[16] cf_indirect_effect_se   cf_indirect_effect_up   cf_indirect_effect_low 
[19] rho                    
<0 rows> (or 0-length row.names)
> # Define values in rho \in [-1, 1] to go across
> rho.values <- seq(-1, 1, by = 0.25)
> # Define the number of boot reps for each
> boot.reps <- 1000
> i <- 0
> 
> # Start the rho loop
> for (rho in rho.values){
+     # Simulate the data: rho, sigma_0, sigma_1, sigma_C
+     rho_sim.data <- simulate.data(rho, 1, 2, 0.25)
+     # Get the truth + estimates + bootstrapped SEs, and save rho value
+     rho.boot  <- estimated.bootstrap(boot.reps, simulated.data,
+         print.progress = FALSE)$estimates
+     rho.boot$rho <- rho
+     # Add to the dataframe.
+     rho.data[i, ] <- rho.boot
+     # Show how far we are.
+     i <- i + 1
+     print(paste0(rho, " in [-1, 1], ", 100 * i / length(rho.values), "% done."))
+     gc()
+ }
[1] "-1 in [-1, 1], 11.1111111111111% done."
[1] "-0.75 in [-1, 1], 22.2222222222222% done."
[1] "-0.5 in [-1, 1], 33.3333333333333% done."
[1] "-0.25 in [-1, 1], 44.4444444444444% done."
[1] "0 in [-1, 1], 55.5555555555556% done."
[1] "0.25 in [-1, 1], 66.6666666666667% done."
[1] "0.5 in [-1, 1], 77.7777777777778% done."
[1] "0.75 in [-1, 1], 88.8888888888889% done."
[1] "1 in [-1, 1], 100% done."
> 
> ## Save the output data.
> rho.data %>% write_csv(file.path(output.folder, "rho-sim-data.csv"))
> 
> proc.time()
    user   system  elapsed 
19931.10    84.29 20018.39 
