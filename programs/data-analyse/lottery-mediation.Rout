
R version 4.5.1 (2025-06-13) -- "Great Square Root"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> #!/usr/bin/R
> ## Senan Hogan-Hennessy, 11 July 2025.
> ## Script to to extract relevant data from Oregon Health Insurance rep package.
> print(Sys.time())
[1] "2025-10-21 17:47:45 EDT"
> set.seed(47)
> 
> ## Packages:
> # functions for data manipulation and visualisation
> library(tidyverse)
── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──
✔ dplyr     1.1.4     ✔ readr     2.1.5
✔ forcats   1.0.0     ✔ stringr   1.5.1
✔ ggplot2   3.5.2     ✔ tibble    3.2.1
✔ lubridate 1.9.4     ✔ tidyr     1.3.1
✔ purrr     1.0.4     
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors
> # Functions for bootstrapping.
> library(boot)
> library(fixest)
> # Package forsemi-parametric MTE by splines.
> library(mgcv)
Loading required package: nlme

Attaching package: ‘nlme’

The following object is masked from ‘package:dplyr’:

    collapse

This is mgcv 1.9-1. For overview type 'help("mgcv-package")'.
> library(splines)
> # Library for better colour choice.
> library(ggthemes)
> # Library for equations in plots
> library(latex2exp)
> # Package for LaTeX tables
> library(xtable)
> 
> 
> # Define folder paths (1) input data (2) clean data.
> data.folder <- file.path("..", "..", "data", "oregon-lottery-icspr")
> figures.folder <- file.path("..", "..", "text", "sections", "figures")
> tables.folder <- file.path("..", "..", "text", "sections", "tables")
> presentation.folder <- file.path("..", "..", "presentation",
+     "presentation-files", "figures")
> # Size of figures.
> fig.width <- 15
> fig.height <- (2 / 3) * fig.width
> presentation.width <- 15
> presentation.height <- (7 / 12) * presentation.width
> # Number of digits to round to.
> digits.no <- 2
> # List of 3 default colours.
> colour.list <- c(
+     "#1f77b4", # Blue
+     "#2ca02c", # Green
+     "#d62728") # Red
> 
> 
> ################################################################################
> ## Load the Oregon Health Insurance Experiment replication data.
> 
> # Load the pre-cleaned Oregon Health data.
> analysis.data <- data.folder %>%
+     file.path("cleaned-oregon-data.csv") %>%
+     read_csv()
Rows: 9957 Columns: 14
── Column specification ────────────────────────────────────────────────────────
Delimiter: ","
dbl (14): lottery_iv, hh_size, any_insurance, any_healthcare, initial_health...

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
> 
> # Factorise the relevant variables.
> analysis.data$hh_size <- factor(analysis.data$hh_size)
> analysis.data$initial_health_location <- factor(
+     analysis.data$initial_health_location)
> 
> # List all the observed control variables
> diagnosis.list <- c(
+     "initial_dia_diagnosis",
+     "initial_ast_diagnosis",
+     "initial_hbp_diagnosis",
+     "initial_emp_diagnosis",
+     "initial_chf_diagnosis",
+     "initial_dep_diagnosis")
> controls.list <- paste(c("hh_size", diagnosis.list), collapse = " + ")
> nocontrols.list <- "hh_size"
> 
> 
> ################################################################################
> ## Define the functions to use.
> 
> # Estimate the values, given a first and second-stages
> estimated.values <- function(firststage.reg, secondstage.reg, totaleffect.reg,
+     data, complier.adjustment = NULL){
+     ### Inputs:
+     ## data, a data frame simulated from above.
+     input_Z0.data <- data
+     input_Z1.data <- data
+     input_D0.data <- data
+     input_D1.data <- data
+     input_Z0.data$Z <- 0
+     input_Z1.data$Z <- 1
+     input_D0.data$D <- 0
+     input_D1.data$D <- 1
+     # calculate the first-stage by prediction
+     firststage.est <- predict(
+         firststage.reg, newdata = input_Z1.data, type = "response") - predict(
+             firststage.reg, newdata = input_Z0.data, type = "response")
+     # Calculate the total effect estimate by prediction.
+     totaleffect.est <- predict(
+         totaleffect.reg, newdata = input_Z1.data) - predict(
+             totaleffect.reg, newdata = input_Z0.data)
+     # calculate the second-stage direct effect
+     direct.est <- predict(
+         secondstage.reg, newdata = input_Z1.data) - predict(
+             secondstage.reg, newdata = input_Z0.data)
+     # calculate the second-stage (controlled) indirect effect
+     indirect.est <- predict(
+         secondstage.reg, newdata = input_D1.data) - predict(
+             secondstage.reg, newdata = input_D0.data)
+     # Add the Kline Walters (2019) IV-type complier adjustment (provided externally).
+     if (!is.null(complier.adjustment)) {
+         indirect.est <- indirect.est + complier.adjustment
+     }
+     # Return the mean estimates.
+     output.list <- list(
+         "first-stage"     = mean(firststage.est, na.rm = TRUE),
+         "total-effect"    = mean(totaleffect.est, na.rm = TRUE),
+         "direct-effect"   = mean(direct.est, na.rm = TRUE),
+         "indirect-effect" = mean(firststage.est * indirect.est, na.rm = TRUE))
+     # Return the output.list
+     return(output.list)
+ }
> 
> # Define a function to estimate mediation, in two-stages (no adjustment).
> mediate.unadjusted <- function(Y, Z, D, X_iv, data,
+     X_minus = NULL, control_iv = NULL, indices = NULL){
+     # Bootstrap sample, if indices provided.
+     if (!is.null(indices)){
+         data <- data[indices, ]
+     }
+     # Make the names consistent
+     data$Y <- data[[Y]]
+     data$Z <- data[[Z]]
+     data$D <- data[[D]]
+     total.formula <- formula(paste0("Y ~ 1 + Z + ", X_minus, " + ", X_iv))
+     firststage.formula <- formula(paste0("D ~ 1 + Z * (", X_iv, ") +", X_minus))
+     secondstage.formula <- formula(paste0("Y ~ 1 + Z * D + ", X_minus, " + ", X_iv))
+     # Start counting coefficients estimated.
+     count.coef <- 0
+     # 0. Total effect regression.
+     totaleffect.reg <- lm(total.formula, data = data)
+     count.coef <- count.coef + length(totaleffect.reg$coefficients)
+     # 1. Regular first-stage (well identified).
+     firststage.reg <- lm(firststage.formula, data = data)
+     count.coef <- count.coef + length(firststage.reg$coefficients)
+     # 2. Estimate second-stage (naive case has no MTEs).
+     unadjusted_secondstage.reg <- lm(secondstage.formula, data = data)
+     count.coef <- count.coef + length(unadjusted_secondstage.reg$coefficients)
+     # Compile the estimates.
+     unadjusted.est <- estimated.values(
+         firststage.reg, unadjusted_secondstage.reg,
+         totaleffect.reg, data,
+         complier.adjustment = NULL)
+     # Return the off-setting estimates.
+     output.list <- c(
+         unadjusted.est$"first-stage",
+         unadjusted.est$"total-effect",
+         unadjusted.est$"direct-effect",
+         unadjusted.est$"indirect-effect",
+         count.coef)
+     return(output.list)
+ }
> 
> #! Test it out, with the specification I want.
> mediate.est <- mediate.unadjusted(
+     Y = "Y_health", Z = "lottery_iv", D = "any_insurance",
+     X_iv = "initial_health_location",
+     X_minus = controls.list,
+     analysis.data)# %>% sample_frac(prop = 1, replace = TRUE))
> print(mediate.est)
[1]  0.212749696  0.045376075  0.036003847  0.009643366 56.000000000
> 
> ## Define a function to Heckman selection correct mediation est, in two-stages.
> # First the Mills ratio selection correction term(s)
> mills.ratio <- function(pi.est){
+     # Inv Mills ratio, taking as input the estimated mediator propensity.
+     return(dnorm(qnorm(pi.est)) / pnorm(qnorm(pi.est)))
+     }
> # The two-stage mediation model.
> mediate.heckit <- function(Y, Z, D, X_iv, data,
+     X_minus = NULL, indices = NULL){
+     # Bootstrap sample, if indices provided.
+     if (!is.null(indices)){
+         data <- data[indices, ]
+     }
+     # Make the names consistent
+     data$Y <- data[[Y]]
+     data$Z <- data[[Z]]
+     data$D <- data[[D]]
+     total.formula <- formula(paste0("Y ~ 1 + Z + ", X_minus))
+     firststage.formula <- formula(paste0("D ~ 1 + Z * (", X_iv, ") +", X_minus))
+     secondstage.formula <- formula(paste0("Y ~ 1 + Z * D + ", X_minus,
+         " + lambda_0 + lambda_1"))
+     # Start counting coefficients estimated.
+     count.coef <- 0
+     # 0. Total effect regression.
+     totaleffect.reg <- lm(total.formula, data = data)
+     count.coef <- count.coef + length(totaleffect.reg$coefficients)
+     # 1. Probit first-stage (well identified).
+     heckit_firststage.reg <- glm(firststage.formula,
+         family = binomial(link = "probit"),
+         data = data)
+     count.coef <- count.coef + length(heckit_firststage.reg$coefficients)
+     # 2. Define the MTEs --- for assumed N(0,1) dist.
+     pi.est <- predict(heckit_firststage.reg, type = "response")
+     data$lambda_0 <- (1 - data$D) * mills.ratio(pi.est) * (
+         - pi.est / (1 - pi.est))
+     data$lambda_1 <- data$D * mills.ratio(pi.est)
+     # 3. Estimate second-stage, including the MTEs.
+     heckit_secondstage.reg <- lm(secondstage.formula, data = data)
+     count.coef <- count.coef + length(heckit_secondstage.reg$coefficients)
+     # Compensate complier difference in AIE, by Kline Walters (2019) IV-type adjustment.
+     input_Z0.data <- data
+     input_Z1.data <- data
+     input_Z0.data$Z <- 0
+     input_Z1.data$Z <- 1
+     pi_0.est <- predict(heckit_firststage.reg, newdata = input_Z0.data)
+     pi_1.est <- predict(heckit_firststage.reg, newdata = input_Z1.data)
+     Gamma.big <-  (pi_1.est * mills.ratio(pi_1.est)
+         - pi_0.est * mills.ratio(pi_0.est)) / (pi_1.est - pi_0.est)
+     rho_0 <- as.numeric(coef(heckit_secondstage.reg)["lambda_0"])
+     rho_1 <- as.numeric(coef(heckit_secondstage.reg)["lambda_1"])
+     complier.adjustment <- (rho_1 - rho_0) * Gamma.big
+     # Compile the estimates.
+     heckit.est <- estimated.values(
+         heckit_firststage.reg, heckit_secondstage.reg,
+         totaleffect.reg, data,
+         complier.adjustment = complier.adjustment)
+     # Return the off-setting estimates.
+     output.list <- c(
+         heckit.est$"first-stage",
+         heckit.est$"total-effect",
+         heckit.est$"direct-effect",
+         heckit.est$"indirect-effect",
+         count.coef)
+     return(output.list)
+ }
> 
> #! Test it out, with the specification I want.
> mediate.est <- mediate.heckit(
+     Y = "Y_health", Z = "lottery_iv", D = "any_healthcare",
+     X_iv = "initial_health_location",
+     X_minus = controls.list,
+     data = analysis.data)# %>% sample_frac(prop = 1, replace = TRUE))
Warning messages:
1: In qnorm(pi.est) : NaNs produced
2: In qnorm(pi.est) : NaNs produced
3: In qnorm(pi.est) : NaNs produced
4: In qnorm(pi.est) : NaNs produced
> print(mediate.est)
[1]  0.04740659  0.05039783  0.02482836  0.01793362 46.00000000
> 
> # Define a function to two-stage semi-parametric MTE for CM effects.
> mediate.semiparametric <- function(Y, Z, D, X_iv, data,
+     X_minus = NULL, indices = NULL){
+     # Bootstrap sample, if indices provided.
+     if (!is.null(indices)){
+         data <- data[indices, ]
+     }
+     # Make the names consistent
+     data$Y <- data[[Y]]
+     data$Z <- data[[Z]]
+     data$D <- data[[D]]
+     total.formula <- formula(paste0("Y ~ 1 + Z +", X_minus))
+     firststage.formula <- formula(paste0("D ~ 1 + Z * (", X_iv, ") +", X_minus))
+     secondstage.formula <- formula(paste0("Y ~ 1 + Z + ", X_minus,
+         " + s(pi.est, bs = 'cr')"))
+     # Get relevant columns for imputation.
+     input_Z0.data <- data
+     input_Z1.data <- data
+     input_D0.data <- data
+     input_D1.data <- data
+     input_Z0.data$Z <- 0
+     input_Z1.data$Z <- 1
+     input_D0.data$D <- 0
+     input_D1.data$D <- 1
+     # Start counting coefficients estimated.
+     count.coef <- 0
+     # 1. Total effect regression.
+     totaleffect.reg <- lm(total.formula, data = data)
+     totaleffect.est <- mean(predict(
+         totaleffect.reg, newdata = input_Z1.data) - predict(
+             totaleffect.reg, newdata = input_Z0.data))
+     count.coef <- count.coef + length(totaleffect.reg$coefficients)
+     # 2. Semi-parametric first-stage
+     mte_firststage.reg <- glm(firststage.formula,
+         family = binomial(link = "probit"),
+         data = data)
+     data$pi.est <- predict(mte_firststage.reg, type = "response")
+     pi_0.est <- predict(mte_firststage.reg, newdata = input_Z0.data, type = "response")
+     pi_1.est <- predict(mte_firststage.reg, newdata = input_Z1.data, type = "response")
+     pi.bar <- mean(pi_1.est - pi_0.est)
+     count.coef <- count.coef + length(mte_firststage.reg$coefficients)
+     # Calculate the levels of pi, accounting for few values in the IV.
+     distinct_mte.values <- min(
+         length(unique(data$pi.est)) - 2, as.integer(nrow(data) / 2000))
+     # 3. Semi-parametric series estimation of the second-stage.
+     mte_secondstage_D0.reg <- gam(secondstage.formula,
+         method = "REML", data = data, subset = (D == 0))
+     mte_secondstage_D1.reg <- gam(secondstage.formula,
+         method = "REML", data = data, subset = (D == 1))
+     count.coef <- count.coef + length(mte_secondstage_D0.reg$coefficients)
+     count.coef <- count.coef + length(mte_secondstage_D1.reg$coefficients)
+     # 4. Compose the CM effects from this object.
+     D_0 <- 1 - mean(data$D)
+     D_1 <- 1 - D_0
+     # 4.1 ADE point estimate, from the MTE model.
+     gammma.est <- coef(mte_secondstage_D0.reg)["Z"]
+     delta_plus.est <- coef(mte_secondstage_D1.reg)["Z"]
+     ade.est <- as.numeric(D_0 * gammma.est + D_1 * delta_plus.est)
+     # 4.2 AIE by using ADE estimate, relative to ATE.
+     # (Avoiding semi-parametric extrapolation, see notes on ATE comparison)
+     delta.est <- delta_plus.est - gammma.est
+     ade_Z0.est <- gammma.est + delta.est * mean(
+         data$D[data$Z == 0])
+     ade_Z1.est <- gammma.est + delta.est * mean(
+         data$D[data$Z == 1])
+     aie.est <- (totaleffect.est - mean(
+         (1 - data$Z) * ade_Z1.est + (data$Z) * ade_Z0.est))
+     # Return the estimates.
+     output.list <- c(
+         pi.bar,
+         totaleffect.est,
+         ade.est,
+         aie.est,
+         count.coef)
+     return(output.list)
+ }
> 
> #! Test it out, with the specification I want.
> mediate.est <- mediate.semiparametric(
+     Y = "Y_health", Z = "lottery_iv", D = "any_healthcare",
+     X_iv = "initial_health_location",
+     X_minus = controls.list,
+     data = analysis.data)# %>% sample_frac(prop = 1, replace = TRUE))
> print(mediate.est)
[1]  0.04740659  0.05039783  0.01987282  0.03054101 70.00000000
> 
> # Define a function to bootstrap.
> mediate.bootstrap <- function(Y, Z, D, X_iv, data,
+         X_minus = NULL, type = "parametric", boot.reps = 10){
+     # Define an empty data.frame.
+     boot.data <- data.frame(matrix(ncol = 4, nrow = 0))
+     names(boot.data) <- c(
+         "First-stage", "ATE", "ADE", "AIE")
+     j <- 1
+     for (i in 1:boot.reps){
+         if ((boot.reps >= 100) & ((100 * i / boot.reps) %% 5 == 0)){
+             cat(paste0(i, " out of ", boot.reps, ", ", 100 * (i / boot.reps),
+                 "% done.", "\n"))
+         }
+         boot.indices <- sample(1:nrow(data), nrow(data), replace = TRUE)
+         if (type == "parametric"){
+             point.est <- mediate.heckit(Y, Z, D, X_iv, data,
+                 X_minus = X_minus, indices = boot.indices)
+             }
+             else if (type == "semi-parametric"){
+                 point.est <- mediate.semiparametric(
+                     Y, Z, D, X_iv, data,
+                     X_minus = X_minus, indices = boot.indices)
+             }
+             else if (type == "unadjusted"){
+                 point.est <- mediate.unadjusted(Y, Z, D, X_iv, data,
+                     X_minus = X_minus, indices = boot.indices)
+             }
+             else {
+                 stop(paste0("The type option only takes values of ",
+                     'c("parametric", "semi-parametric", "unadjusted").'))
+             }
+         boot.data[i, ] <- point.est
+     }
+     return(boot.data)
+ }
> 
> #! Test it out.
> mediate.boot <- mediate.bootstrap(
+     Y = "Y_health", Z = "lottery_iv", D = "any_healthcare",
+     X_iv = "initial_health_location",
+     X_minus = controls.list,
+     data = analysis.data, type = "unadjusted", boot.reps = 10)
Warning messages:
1: In matrix(value, n, p) :
  data length [5] is not a sub-multiple or multiple of the number of columns [4]
2: In matrix(value, n, p) :
  data length [5] is not a sub-multiple or multiple of the number of columns [4]
3: In matrix(value, n, p) :
  data length [5] is not a sub-multiple or multiple of the number of columns [4]
4: In matrix(value, n, p) :
  data length [5] is not a sub-multiple or multiple of the number of columns [4]
5: In matrix(value, n, p) :
  data length [5] is not a sub-multiple or multiple of the number of columns [4]
6: In matrix(value, n, p) :
  data length [5] is not a sub-multiple or multiple of the number of columns [4]
7: In matrix(value, n, p) :
  data length [5] is not a sub-multiple or multiple of the number of columns [4]
8: In matrix(value, n, p) :
  data length [5] is not a sub-multiple or multiple of the number of columns [4]
9: In matrix(value, n, p) :
  data length [5] is not a sub-multiple or multiple of the number of columns [4]
10: In matrix(value, n, p) :
  data length [5] is not a sub-multiple or multiple of the number of columns [4]
> print(mediate.boot)
   First-stage        ATE        ADE          AIE
1   0.04572406 0.05487293 0.05664556 -0.001762693
2   0.05427874 0.04526443 0.04735536 -0.002063254
3   0.04974240 0.03993207 0.04122460 -0.001231346
4   0.05886424 0.05663407 0.05928204 -0.002630554
5   0.03711879 0.06809338 0.06945689 -0.001283438
6   0.04968800 0.05527965 0.05748234 -0.002207341
7   0.05095388 0.06022958 0.06264016 -0.002282312
8   0.03955750 0.04134506 0.04277944 -0.001366061
9   0.04396096 0.04244741 0.04435888 -0.001861247
10  0.04088122 0.05267428 0.05443675 -0.001721278
> 
> ## Define a function to wrap around all the others.
> mediate.selection <- function(Y, Z, D, X_iv, X_minus, data,
+     type = "parametric", boot.reps = 10){
+     # Calculate the point estimates.
+     if (type == "parametric"){
+         point.est <- mediate.heckit(Y, Z, D, X_iv, data, X_minus = X_minus)
+     }
+     else if (type == "semi-parametric"){
+         point.est <- mediate.semiparametric(Y, Z, D, X_iv, data, X_minus = X_minus)
+     }
+     else if (type == "unadjusted"){
+         point.est <- mediate.unadjusted(Y, Z, D, X_iv, data, X_minus = X_minus)
+     }
+     else {
+         stop(paste0("The type option only takes values of ",
+             'c("parametric", "semi-parametric", "unadjusted").'))
+     }
+     count.coef <- point.est[5]
+     # Calculate the SEs by a non-parametric bootstrap.
+     if (!is.null(boot.reps)){
+         if (boot.reps < 500){
+             print(paste0("Attempting to bootstrap with fewer than 500 reps.",
+                 "  Are you sure?  This is likely not enough for convergence."))
+         }
+         point.boot <- mediate.bootstrap(
+             Y = Y, Z = Z, D = D, X_minus = X_minus, X_iv = X_iv,
+             data = data, type = type, boot.reps = boot.reps)
+         point.se <- as.matrix(c(
+             sd(100 * point.boot$"First-stage"),
+             sd(100 * point.boot$"ATE"),
+             sd(100 * point.boot$"ADE"),
+             sd(100 * point.boot$"AIE"),
+             sd(point.boot$"AIE" / point.boot$"ATE")))
+     }
+     else {
+         point.se <- as.matrix(c(
+             NA,
+             NA,
+             NA,
+             NA,
+             NA))
+     }
+     # Report output
+     point.est <- as.matrix(c(100 * point.est[1:4], point.est[4] / point.est[2]))
+     tratio <- as.matrix(point.est / point.se)
+     ptratio <- as.matrix(2 * pt(abs(tratio),
+         df = nrow(data) - count.coef, lower.tail = FALSE))
+     # Preapred object to putput.
+     out <- list(
+         coefficients = point.est,
+         SE = point.se,
+         tratio = tratio,
+         ptratio = ptratio,
+         type = type,
+         variables = paste(Z, D, Y, sep = ", "),
+         boot.reps = boot.reps)
+     rownames(out$coefficients) <-
+         c("First-stage", "ATE", "ADE", "AIE", "Proportion, AIE / ATE")
+     rownames(out$SE)      <-rownames(out$coefficients)
+     rownames(out$tratio)  <-rownames(out$coefficients)
+     rownames(out$ptratio) <-rownames(out$coefficients)
+     class(out) <- "mediate.selection"
+     return(out)
+ }
> 
> # Print applied to the function.
> print.mediate.selection <- function(x, digits = 4, ...){
+     cat("Treatment, Mediator, Outcome: \n")
+     cat(x$variables)
+     cat("\n")
+     est <- cbind(x$coefficients, x$SE)
+     colnames(est) <- c("Coefficients", "SE")
+     cat(paste0("\n", x$type, " Estimates, With SEs from ", x$boot.reps, " bootstrap replications."))
+     cat("\n\n")
+     print.default(format(est, digits = digits), quote = FALSE)
+ }
> 
> # Apply the summary function, to get a presentable output.
> summary.mediate.selection <- function(object, ...){
+     TAP <- cbind(
+         Estimate = coef(object),
+         SE = object$SE,
+         ptratio = object$ptratio )
+     colnames(TAP) <- c("Estimate", "SE", "P")
+     res <- list(variables = object$variables, coefficients = TAP)  
+     class(res) <- "summary.larf"
+     return(res)
+ }
> 
> # Presentable summary, via printing.
> print.summary.mediate.selection <- function(x, digits = 4, ...){
+     cat("Treatment, Mediator, Outcome: \n")
+     cat(x$variables)
+     cat("\n")
+     print.default(round(x$coefficients, digits = digits), quote = FALSE)
+ }
> 
> 
> ################################################################################
> ## Show the regular location is a strong IV for healthcare visits.
> 
> # Note values in usual health location:
> initial_health_location.list <- c(
+     "1. Private clinic",
+     "2. Public clinic",
+     "3. Hospital clinic",
+     "4. Hospital A&E",
+     "5. Urgent care",
+     "6. Other clinic",
+     "7. No regular")
> 
> # Show that the health location influences healthcare take-up
> location.data <- analysis.data %>%
+     mutate(initial_health_location_name =
+         ifelse(initial_health_location == 1, initial_health_location.list[1],
+         ifelse(initial_health_location == 2, initial_health_location.list[2],
+         ifelse(initial_health_location == 3, initial_health_location.list[3],
+         ifelse(initial_health_location == 4, initial_health_location.list[4],
+         ifelse(initial_health_location == 5, initial_health_location.list[5],
+         ifelse(initial_health_location == 6, initial_health_location.list[6],
+         ifelse(initial_health_location == 7, initial_health_location.list[7],
+             "WARNING")))))))) %>%
+     group_by(initial_health_location_name) %>%
+     summarise(
+         any_healthcare_mean = mean(any_healthcare, na.rm = TRUE),
+         any_healthcare_sd = sd(any_healthcare, na.rm = TRUE),
+         count = n()) %>%
+     ungroup() %>%
+     mutate(any_healthcare_se = any_healthcare_sd / (count^(0.5)),
+         any_healthcare_mean_lower = any_healthcare_mean - 1.96 * any_healthcare_se,
+         any_healthcare_mean_upper = any_healthcare_mean + 1.96 * any_healthcare_se)
> 
> # Draw the horizontal bar chart
> location.plot <- location.data %>%
+     ggplot(aes(x = initial_health_location_name)) +
+     # Bars of the mean
+     geom_bar(aes(y = any_healthcare_mean, fill = initial_health_location_name),
+         colour = "black", stat = "identity") +
+     # Error bars
+     geom_errorbar(
+         aes(ymin = any_healthcare_mean_lower, ymax = any_healthcare_mean_upper),
+         width = 0.2, position = position_dodge(0.9)) +
+     # Make horizontal and format.
+     coord_flip() +
+     theme_bw() +
+     scale_x_discrete(name = "", limits = initial_health_location.list[7:1]) +
+     scale_y_continuous(expand = c(0, 0),
+         name = TeX(r"(Visited healthcare in following 12 months, $\Pr( \,D_i = 1 \, | \, X^{IV}_i \,)$)"),
+         limits = c(0, 1.025), oob = scales::rescale_none,
+         breaks = seq(0, 1, by = 0.1)) +
+     ggtitle("Usual Healthcare Location") +
+     theme(legend.position = "none",
+         axis.text.y = element_text(hjust = 0),
+         plot.title = element_text(hjust = 0, size = rel(1)),
+         plot.title.position = "plot",
+         plot.margin = unit(c(0, 2, 0, 0), "mm"))
> # Save the plot.
> ggsave(file.path(figures.folder, "location-effects.png"),
+     plot = location.plot,
+     units = "cm", width = fig.width, height = fig.height)
> 
> # Show the OLS correlation between D (mediator) and Y (outcome.)
> library(margins)
> health.reg <- lm(
+     formula(paste0("Y_health ~ 1 + any_healthcare + ", nocontrols.list)),
+     data = analysis.data)
> print(summary(health.reg))

Call:
lm(formula = formula(paste0("Y_health ~ 1 + any_healthcare + ", 
    nocontrols.list)), data = analysis.data)

Residuals:
    Min      1Q  Median      3Q     Max 
-0.6845 -0.5142  0.3310  0.4858  0.4858 

Coefficients:
               Estimate Std. Error t value Pr(>|t|)    
(Intercept)     0.61469    0.01030  59.660  < 2e-16 ***
any_healthcare -0.10052    0.01122  -8.959  < 2e-16 ***
hh_size2        0.05435    0.01098   4.949 7.58e-07 ***
hh_size3        0.06980    0.11353   0.615    0.539    
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 0.4941 on 9953 degrees of freedom
Multiple R-squared:  0.01119,	Adjusted R-squared:  0.0109 
F-statistic: 37.56 on 3 and 9953 DF,  p-value: < 2.2e-16

> happy.reg <- lm(
+     formula(paste0("Y_happy ~ 1 + any_healthcare + ", nocontrols.list)),
+     data = analysis.data)
> print(summary(happy.reg))

Call:
lm(formula = formula(paste0("Y_happy ~ 1 + any_healthcare + ", 
    nocontrols.list)), data = analysis.data)

Residuals:
    Min      1Q  Median      3Q     Max 
-0.6738 -0.6016  0.3508  0.3984  0.4853 

Coefficients:
               Estimate Std. Error t value Pr(>|t|)    
(Intercept)     0.62617    0.01010  61.987  < 2e-16 ***
any_healthcare -0.02457    0.01100  -2.234   0.0255 *  
hh_size2        0.04762    0.01077   4.423 9.84e-06 ***
hh_size3       -0.08692    0.11131  -0.781   0.4349    
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 0.4844 on 9953 degrees of freedom
Multiple R-squared:  0.002702,	Adjusted R-squared:  0.002401 
F-statistic: 8.989 on 3 and 9953 DF,  p-value: 6.085e-06

> # Show the IV effect between D (mediator) and Y (outcome.)
> library(fixest)
> health.iv <- feols(
+     formula(paste0("Y_health ~ 1 + ", nocontrols.list,
+         "| any_healthcare ~ factor(initial_health_location)")),
+     data = analysis.data)
> print(summary(health.iv))
TSLS estimation - Dep. Var.: Y_health
                  Endo.    : any_healthcare
                  Instr.   : factor(initial_health_location)
Second stage: Dep. Var.: Y_health
Observations: 9,957
Standard-errors: IID 
                   Estimate Std. Error t value   Pr(>|t|)    
(Intercept)        0.391974   0.058250 6.72913 1.8008e-11 ***
fit_any_healthcare 0.194650   0.076781 2.53513 1.1256e-02 *  
hh_size2           0.076599   0.012717 6.02343 1.7681e-09 ***
hh_size3           0.137157   0.118681 1.15568 2.4784e-01    
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
RMSE: 0.51086   Adj. R2: -0.057875
F-test (1st stage), any_healthcare: stat = 38.8, p < 2.2e-16  , on 6 and 9,948 DoF.
                        Wu-Hausman: stat = 16.2, p = 5.739e-5 , on 1 and 9,952 DoF.
                            Sargan: stat = 69.1, p = 1.571e-13, on 5 DoF.
> happy.iv <- feols(
+     formula(paste0("Y_happy ~ 1 + ", nocontrols.list,
+     "| any_healthcare ~ factor(initial_health_location)")),
+     data = analysis.data)
> print(summary(happy.iv))
TSLS estimation - Dep. Var.: Y_happy
                  Endo.    : any_healthcare
                  Instr.   : factor(initial_health_location)
Second stage: Dep. Var.: Y_happy
Observations: 9,957
Standard-errors: IID 
                    Estimate Std. Error   t value   Pr(>|t|)    
(Intercept)         0.403675   0.057182  7.059480 1.7829e-12 ***
fit_any_healthcare  0.270307   0.075373  3.586261 3.3706e-04 ***
hh_size2            0.069850   0.012484  5.595286 2.2609e-08 ***
hh_size3           -0.019626   0.116504 -0.168459 8.6623e-01    
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
RMSE: 0.50149   Adj. R2: -0.069612
F-test (1st stage), any_healthcare: stat = 38.8, p < 2.2e-16 , on 6 and 9,948 DoF.
                        Wu-Hausman: stat = 16.8, p = 4.14e-5 , on 1 and 9,952 DoF.
                            Sargan: stat = 38.0, p = 3.733e-7, on 5 DoF.
> 
> # Show the structural estimate for mediator complier's D -> Y effect.
> mediate.est <- mediate.selection(
+     Y = "Y_health", Z = "lottery_iv", D = "any_healthcare",
+     X_iv = "initial_health_location",
+     X_minus = controls.list,
+     boot.reps = NULL,
+     type = "parametric",
+     data = analysis.data)
Warning messages:
1: In qnorm(pi.est) : NaNs produced
2: In qnorm(pi.est) : NaNs produced
3: In qnorm(pi.est) : NaNs produced
4: In qnorm(pi.est) : NaNs produced
> print(coeftable(mediate.est)["AIE", "Estimate"] /
+     coeftable(mediate.est)["First-stage", "Estimate"])
[1] 0.3782938
> 
> # Get the F statistic, for location -> D (healthcare.)
> library(car)
Loading required package: carData

Attaching package: ‘car’

The following object is masked from ‘package:boot’:

    logit

The following object is masked from ‘package:dplyr’:

    recode

The following object is masked from ‘package:purrr’:

    some

> print(mean(analysis.data$any_healthcare, na.rm = TRUE))
[1] 0.7324495
> location.reg <- lm(
+     formula(paste0("any_healthcare ~ 1 + factor(initial_health_location)",
+         " + lottery_iv * ", nocontrols.list)),
+     data = analysis.data)
> print(summary(location.reg))

Call:
lm(formula = formula(paste0("any_healthcare ~ 1 + factor(initial_health_location)", 
    " + lottery_iv * ", nocontrols.list)), data = analysis.data)

Residuals:
    Min      1Q  Median      3Q     Max 
-0.8156 -0.5083  0.2256  0.2777  0.5701 

Coefficients:
                                  Estimate Std. Error t value Pr(>|t|)    
(Intercept)                       0.756124   0.009485  79.722  < 2e-16 ***
factor(initial_health_location)2  0.018263   0.010835   1.686   0.0919 .  
factor(initial_health_location)3  0.010851   0.018545   0.585   0.5585    
factor(initial_health_location)4 -0.083793   0.015611  -5.367 8.17e-08 ***
factor(initial_health_location)5 -0.109751   0.021128  -5.195 2.09e-07 ***
factor(initial_health_location)6  0.017671   0.017896   0.987   0.3234    
factor(initial_health_location)7 -0.247796   0.020068 -12.348  < 2e-16 ***
lottery_iv                        0.041249   0.010403   3.965 7.39e-05 ***
hh_size2                         -0.078389   0.014320  -5.474 4.51e-08 ***
hh_size3                         -0.774387   0.436098  -1.776   0.0758 .  
lottery_iv:hh_size2              -0.007573   0.019474  -0.389   0.6974    
lottery_iv:hh_size3               0.589468   0.448164   1.315   0.1884    
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 0.436 on 9945 degrees of freedom
Multiple R-squared:  0.03117,	Adjusted R-squared:  0.0301 
F-statistic: 29.09 on 11 and 9945 DF,  p-value: < 2.2e-16

> iv.list <- paste0("factor(initial_health_location)", 2:7)
> print(car::linearHypothesis(location.reg, test = "F", iv.list))

Linear hypothesis test:
factor(initial_health_location)2 = 0
factor(initial_health_location)3 = 0
factor(initial_health_location)4 = 0
factor(initial_health_location)5 = 0
factor(initial_health_location)6 = 0
factor(initial_health_location)7 = 0

Model 1: restricted model
Model 2: any_healthcare ~ 1 + factor(initial_health_location) + lottery_iv * 
    hh_size

  Res.Df    RSS Df Sum of Sq      F    Pr(>F)    
1   9951 1934.2                                  
2   9945 1890.4  6    43.765 38.372 < 2.2e-16 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
> 
> 
> ################################################################################
> ## Estimate the CM effects with my methods.
> 
> # State how many bootstrap replications are needed.
> boot.reps <- 10^3
> 
> ## Panel A: Self-reported healthiness.
> # Naive selection-on-observables
> unadjusted.est <- mediate.selection(
+     Y = "Y_health", Z = "lottery_iv", D = "any_healthcare",
+     X_iv = "initial_health_location", X_minus = controls.list,
+     type = "unadjusted",
+     data = analysis.data,
+     boot.reps = boot.reps)
50 out of 1000, 5% done.
100 out of 1000, 10% done.
150 out of 1000, 15% done.
200 out of 1000, 20% done.
250 out of 1000, 25% done.
300 out of 1000, 30% done.
350 out of 1000, 35% done.
400 out of 1000, 40% done.
450 out of 1000, 45% done.
500 out of 1000, 50% done.
550 out of 1000, 55% done.
600 out of 1000, 60% done.
650 out of 1000, 65% done.
700 out of 1000, 70% done.
750 out of 1000, 75% done.
800 out of 1000, 80% done.
850 out of 1000, 85% done.
900 out of 1000, 90% done.
950 out of 1000, 95% done.
1000 out of 1000, 100% done.
There were 50 or more warnings (use warnings() to see the first 50)
> print(unadjusted.est)
Treatment, Mediator, Outcome: 
lottery_iv, any_healthcare, Y_health

unadjusted Estimates, With SEs from 1000 bootstrap replications.

                      Coefficients SE      
First-stage            4.72927      0.88386
ATE                    4.53761      0.90739
ADE                    4.73910      0.90845
AIE                   -0.19438      0.06289
Proportion, AIE / ATE -0.04284      0.01791
> # Parametric MTE
> parametric.est <- mediate.selection(
+     Y = "Y_health", Z = "lottery_iv", D = "any_healthcare",
+     X_iv = "initial_health_location", X_minus = controls.list,
+     type = "parametric",
+     data = analysis.data,
+     boot.reps = boot.reps)
50 out of 1000, 5% done.
100 out of 1000, 10% done.
150 out of 1000, 15% done.
200 out of 1000, 20% done.
250 out of 1000, 25% done.
300 out of 1000, 30% done.
350 out of 1000, 35% done.
400 out of 1000, 40% done.
450 out of 1000, 45% done.
500 out of 1000, 50% done.
550 out of 1000, 55% done.
600 out of 1000, 60% done.
650 out of 1000, 65% done.
700 out of 1000, 70% done.
750 out of 1000, 75% done.
800 out of 1000, 80% done.
850 out of 1000, 85% done.
900 out of 1000, 90% done.
950 out of 1000, 95% done.
1000 out of 1000, 100% done.
There were 50 or more warnings (use warnings() to see the first 50)
> print(parametric.est)
Treatment, Mediator, Outcome: 
lottery_iv, any_healthcare, Y_health

parametric Estimates, With SEs from 1000 bootstrap replications.

                      Coefficients SE    
First-stage           4.7407       0.8792
ATE                   5.0398       0.9542
ADE                   2.4828       1.1707
AIE                   1.7934       0.5470
Proportion, AIE / ATE 0.3558       0.1354
> # Semi-parametric MTE
> semiparametric.est <- mediate.selection(
+     Y = "Y_health", Z = "lottery_iv", D = "any_healthcare",
+     X_iv = "initial_health_location", X_minus = controls.list,
+     type = "semi-parametric",
+     data = analysis.data,
+     boot.reps = boot.reps)
50 out of 1000, 5% done.
100 out of 1000, 10% done.
150 out of 1000, 15% done.
200 out of 1000, 20% done.
250 out of 1000, 25% done.
300 out of 1000, 30% done.
350 out of 1000, 35% done.
400 out of 1000, 40% done.
450 out of 1000, 45% done.
500 out of 1000, 50% done.
550 out of 1000, 55% done.
600 out of 1000, 60% done.
650 out of 1000, 65% done.
700 out of 1000, 70% done.
750 out of 1000, 75% done.
800 out of 1000, 80% done.
850 out of 1000, 85% done.
900 out of 1000, 90% done.
950 out of 1000, 95% done.
1000 out of 1000, 100% done.
There were 50 or more warnings (use warnings() to see the first 50)
> print(semiparametric.est)
Treatment, Mediator, Outcome: 
lottery_iv, any_healthcare, Y_health

semi-parametric Estimates, With SEs from 1000 bootstrap replications.

                      Coefficients SE    
First-stage           4.7407       0.8376
ATE                   5.0398       0.9724
ADE                   1.9873       1.3119
AIE                   3.0541       0.8668
Proportion, AIE / ATE 0.6060       0.2223
> 
> # Show the inferred indirect effect among mediator compliers.
> print(100 * (coef(summary(unadjusted.est))["AIE", "Estimate"] / 100) /
+     (coef(summary(unadjusted.est))["First-stage", "Estimate"] / 100))
[1] -4.110045
> print(100 * (coef(summary(parametric.est))["AIE", "Estimate"] / 100) /
+     (coef(summary(parametric.est))["First-stage", "Estimate"] / 100))
[1] 37.82938
> print(100 * (coef(summary(semiparametric.est))["AIE", "Estimate"] / 100) /
+     (coef(summary(semiparametric.est))["First-stage", "Estimate"] / 100))
[1] 64.42356
> 
> # Extract the relevant estimates.
> panelA.data <- data.frame(
+     unadjusted_point = coef(summary(unadjusted.est))[, "Estimate"],
+     unadjusted_se = coef(summary(unadjusted.est))[, "SE"],
+     parametric_point = coef(summary(parametric.est))[, "Estimate"],
+     parametric_se = coef(summary(parametric.est))[, "SE"],
+     semiparametric_point = coef(summary(semiparametric.est))[, "Estimate"],
+     semiparametric_se = coef(summary(semiparametric.est))[, "SE"])
> 
> # Save the estimates in data.
> effects.extract <- function(mediate.est, model.name){
+     # Compile the mediation regression results.
+     reg.summary <- summary(mediate.est)
+     # Get the total effect estimates.
+     total.est      <- coeftable(reg.summary)["ATE", "Estimate"]
+     total.ci.upper <- total.est + 1.96 * coeftable(reg.summary)["ATE", "SE"]
+     total.ci.lower <- total.est - 1.96 * coeftable(reg.summary)["ATE", "SE"]
+     # Get the direct effect estimates.
+     direct.est       <- coeftable(reg.summary)["ADE", "Estimate"]
+     direct.ci.upper  <- direct.est + 1.96 * coeftable(reg.summary)["ADE", "SE"]
+     direct.ci.lower  <- direct.est - 1.96 * coeftable(reg.summary)["ADE", "SE"]
+     # Get the indirect effect estimates.
+     indirect.est       <- coeftable(reg.summary)["AIE", "Estimate"]
+     indirect.ci.upper  <- indirect.est + 1.96 * coeftable(reg.summary)["AIE", "SE"]
+     indirect.ci.lower  <- indirect.est - 1.96 * coeftable(reg.summary)["AIE", "SE"]
+     # Get the percent mediated estimates.
+     permediated.est      <- coeftable(reg.summary)["Proportion, AIE / ATE", "Estimate"]
+     permediated.ci.upper <- permediated.est + 1.96 * coeftable(reg.summary)["Proportion, AIE / ATE", "SE"]
+     permediated.ci.lower <- permediated.est - 1.96 * coeftable(reg.summary)["Proportion, AIE / ATE", "SE"]
+     # Put it all into a dataframe.
+     data.return <- data.frame(
+         effect = c("Total", "Direct", "Indirect", "Percent Mediated"),
+         pointest = c(total.est, direct.est, indirect.est, permediated.est),
+         upperest = c(total.ci.upper, direct.ci.upper, indirect.ci.upper, permediated.ci.upper),
+         lowerest = c(total.ci.lower, direct.ci.lower, indirect.ci.lower, permediated.ci.lower))
+     # Label it with the model name
+     data.return <- data.return %>% mutate(model = model.name)
+     return(data.return)
+ }
> 
> # Collect estimates for plotting.
> Y_health.data <- rbind(
+     effects.extract(unadjusted.est,     "Conventional"),
+     effects.extract(parametric.est,     "Parametric MTE"),
+     effects.extract(semiparametric.est, "Semi-parametric MTE"))
> 
> # Clean up the data for a table.
> panelA.table <- panelA.data %>%
+     signif(digits.no) %>%
+     format(scientific = FALSE)
> 
> panelA.table$unadjusted_se <- panelA.table$unadjusted_se %>% paste0("(", ., ")")
> panelA.table$parametric_se <- panelA.table$parametric_se %>% paste0("(", ., ")")
> panelA.table$semiparametric_se <- panelA.table$semiparametric_se %>% paste0("(", ., ")")
> panelA.table <- data.frame(t(panelA.table))
> # Add on the first column
> panelA.table$model <- c(
+     "Unadjusted", "", "Parametric MTE", "", "Semi-parametric MTE", "")
> panelA.table <- panelA.table[c(6, 1:5)]
> 
> # Save the LaTeX table
> panelA.table %>%
+     xtable() %>%
+     print(
+         digits = digits.no,
+         sanitize.colnames.function = identity,
+         sanitize.text.function = identity,
+         NA.string = " ",
+         include.colnames = FALSE,
+         include.rownames = FALSE,
+         only.contents = TRUE,
+         hline.after = NULL,
+         format.args = list(big.mark = ","),
+         file = file.path(tables.folder, "cm-oregon-health.tex"))
> 
> 
> ## Panel B: Self-reported happiness.
> # Naive selection-on-observables
> unadjusted.est <- mediate.selection(
+     Y = "Y_happy", Z = "lottery_iv", D = "any_healthcare",
+     X_iv = "initial_health_location", X_minus = controls.list,
+     type = "unadjusted",
+     data = analysis.data,
+     boot.reps = boot.reps)
50 out of 1000, 5% done.
100 out of 1000, 10% done.
150 out of 1000, 15% done.
200 out of 1000, 20% done.
250 out of 1000, 25% done.
300 out of 1000, 30% done.
350 out of 1000, 35% done.
400 out of 1000, 40% done.
450 out of 1000, 45% done.
500 out of 1000, 50% done.
550 out of 1000, 55% done.
600 out of 1000, 60% done.
650 out of 1000, 65% done.
700 out of 1000, 70% done.
750 out of 1000, 75% done.
800 out of 1000, 80% done.
850 out of 1000, 85% done.
900 out of 1000, 90% done.
950 out of 1000, 95% done.
1000 out of 1000, 100% done.
There were 50 or more warnings (use warnings() to see the first 50)
> print(unadjusted.est)
Treatment, Mediator, Outcome: 
lottery_iv, any_healthcare, Y_happy

unadjusted Estimates, With SEs from 1000 bootstrap replications.

                      Coefficients SE      
First-stage           4.729271     0.862631
ATE                   7.097649     0.961191
ADE                   7.039325     0.960851
AIE                   0.066696     0.052298
Proportion, AIE / ATE 0.009397     0.007681
> # Parametric MTE
> parametric.est <- mediate.selection(
+     Y = "Y_happy", Z = "lottery_iv", D = "any_healthcare",
+     X_iv = "initial_health_location", X_minus = controls.list,
+     type = "parametric",
+     data = analysis.data,
+     boot.reps = boot.reps)
50 out of 1000, 5% done.
100 out of 1000, 10% done.
150 out of 1000, 15% done.
200 out of 1000, 20% done.
250 out of 1000, 25% done.
300 out of 1000, 30% done.
350 out of 1000, 35% done.
400 out of 1000, 40% done.
450 out of 1000, 45% done.
500 out of 1000, 50% done.
550 out of 1000, 55% done.
600 out of 1000, 60% done.
650 out of 1000, 65% done.
700 out of 1000, 70% done.
750 out of 1000, 75% done.
800 out of 1000, 80% done.
850 out of 1000, 85% done.
900 out of 1000, 90% done.
950 out of 1000, 95% done.
1000 out of 1000, 100% done.
There were 50 or more warnings (use warnings() to see the first 50)
> print(parametric.est)
Treatment, Mediator, Outcome: 
lottery_iv, any_healthcare, Y_happy

parametric Estimates, With SEs from 1000 bootstrap replications.

                      Coefficients SE     
First-stage           4.74066      0.87393
ATE                   7.50399      0.98866
ADE                   4.96055      1.13112
AIE                   1.85782      0.50925
Proportion, AIE / ATE 0.24758      0.07456
> # Semi-parametric MTE
> semiparametric.est <- mediate.selection(
+     Y = "Y_happy", Z = "lottery_iv", D = "any_healthcare",
+     X_iv = "initial_health_location", X_minus = controls.list,
+     type = "semi-parametric",
+     data = analysis.data,
+     boot.reps = boot.reps)
50 out of 1000, 5% done.
100 out of 1000, 10% done.
150 out of 1000, 15% done.
200 out of 1000, 20% done.
250 out of 1000, 25% done.
300 out of 1000, 30% done.
350 out of 1000, 35% done.
400 out of 1000, 40% done.
450 out of 1000, 45% done.
500 out of 1000, 50% done.
550 out of 1000, 55% done.
600 out of 1000, 60% done.
650 out of 1000, 65% done.
700 out of 1000, 70% done.
750 out of 1000, 75% done.
800 out of 1000, 80% done.
850 out of 1000, 85% done.
900 out of 1000, 90% done.
950 out of 1000, 95% done.
1000 out of 1000, 100% done.
There were 50 or more warnings (use warnings() to see the first 50)
> print(semiparametric.est)
Treatment, Mediator, Outcome: 
lottery_iv, any_healthcare, Y_happy

semi-parametric Estimates, With SEs from 1000 bootstrap replications.

                      Coefficients SE    
First-stage           4.7407       0.8445
ATE                   7.5040       0.9333
ADE                   4.9597       1.1990
AIE                   2.5455       0.7447
Proportion, AIE / ATE 0.3392       0.1112
> 
> # Extract the relevant figures.
> panelB.data <- data.frame(
+     unadjusted_point = coef(summary(unadjusted.est))[, "Estimate"],
+     unadjusted_se = coef(summary(unadjusted.est))[, "SE"],
+     parametric_point = coef(summary(parametric.est))[, "Estimate"],
+     parametric_se = coef(summary(parametric.est))[, "SE"],
+     semiparametric_point = coef(summary(semiparametric.est))[, "Estimate"],
+     semiparametric_se = coef(summary(semiparametric.est))[, "SE"])
> 
> # Save for a plot.
> Y_happy.data <- rbind(
+     effects.extract(unadjusted.est,     "Conventional"),
+     effects.extract(parametric.est,     "Parametric MTE"),
+     effects.extract(semiparametric.est, "Semi-parametric MTE"))
> 
> # Show the inferred controlled indirect effect.
> print(100 * (coef(summary(unadjusted.est))["AIE", "Estimate"] / 100) /
+     (coef(summary(unadjusted.est))["First-stage", "Estimate"] / 100))
[1] 1.410291
> print(100 * (coef(summary(parametric.est))["AIE", "Estimate"] / 100) /
+     (coef(summary(parametric.est))["First-stage", "Estimate"] / 100))
[1] 39.18906
> print(100 * (coef(summary(semiparametric.est))["AIE", "Estimate"] / 100) /
+     (coef(summary(semiparametric.est))["First-stage", "Estimate"] / 100))
[1] 53.69589
> 
> # Clean up the data.
> panelB.table <- panelB.data %>%
+     signif(digits.no) %>%
+     format(scientific = FALSE)
> 
> panelB.table$unadjusted_se <- panelB.table$unadjusted_se %>% paste0("(", ., ")")
> panelB.table$parametric_se <- panelB.table$parametric_se %>% paste0("(", ., ")")
> panelB.table$semiparametric_se <- panelB.table$semiparametric_se %>% paste0("(", ., ")")
> panelB.table <- data.frame(t(panelB.table))
> # Add on the first column
> panelB.table$model <- c(
+     "Unadjusted", "", "Parametric MTE", "", "Semi-parametric MTE", "")
> panelB.table <- panelB.table[c(6, 1:5)]
> 
> # Save the LaTeX table
> panelB.table %>%
+     xtable() %>%
+     print(
+         digits = digits.no,
+         sanitize.colnames.function = identity,
+         sanitize.text.function = identity,
+         NA.string = " ",
+         include.colnames = FALSE,
+         include.rownames = FALSE,
+         only.contents = TRUE,
+         hline.after = NULL,
+         format.args = list(big.mark = ","),
+         file = file.path(tables.folder, "cm-oregon-happy.tex"))
> 
> 
> ################################################################################
> ## Plot the results
> 
> # Plot health results in a bar chart.
> health_mediation.plot <- Y_health.data %>%
+     filter(effect != "Percent Mediated") %>%
+     ggplot(aes(
+         fill = factor(effect, levels = c("Total", "Direct", "Indirect")),
+         x = model)) +
+     geom_bar(aes(y = pointest),
+         stat = "identity", position = "dodge", colour = "black") +
+     geom_errorbar(aes(ymin = lowerest, ymax = upperest),
+         size = 2 / 3,
+         stat = "identity", position = position_dodge(0.9), width = 1 / 3) +
+     theme_bw() +
+     geom_hline(yintercept = 0, linetype = "dashed") +
+     scale_fill_discrete(
+         name = "",
+         limits = c("Total", "Direct", "Indirect"),
+         type = colour.list[c(3, 1, 2)]) +
+     scale_x_discrete(
+         name = "",
+         limits = c("Conventional", "Parametric MTE", "Semi-parametric MTE")) +
+     scale_y_continuous(expand = c(0, 0, 0.01, 0),
+         limits = c(-0.1, 8), breaks = seq(-10, 10, by = 1),
+         oob = scales::rescale_none,
+         name = "") +
+     ggtitle("Estimate, percent effect on subjective health") +
+     theme(plot.title = element_text(size = rel(1), hjust = 0),
+         plot.title.position = "plot",
+         plot.margin = unit(c(0, 3, 0.25, 0), "mm"),
+         legend.position = c(0.66, 0.9375),
+         legend.direction = "horizontal")
Warning messages:
1: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.
ℹ Please use `linewidth` instead. 
2: A numeric `legend.position` argument in `theme()` was deprecated in ggplot2
3.5.0.
ℹ Please use the `legend.position.inside` argument of `theme()` instead. 
> # Save this file
> ggsave(file.path(figures.folder, "mediation-health.png"),
+     plot = health_mediation.plot,
+     units = "cm",
+     width = presentation.width, height = presentation.height)
> 
> # Plot happiness results in a bar chart.
> happy_mediation.plot <- Y_happy.data %>%
+     filter(effect != "Percent Mediated") %>%
+     ggplot(aes(
+         fill = factor(effect, levels = c("Total", "Direct", "Indirect")),
+         x = model)) +
+     geom_bar(aes(y = pointest),
+         stat = "identity", position = "dodge", colour = "black") +
+     geom_errorbar(aes(ymin = lowerest, ymax = upperest),
+         size = 2 / 3,
+         stat = "identity", position = position_dodge(0.9), width = 1 / 3) +
+     theme_bw() +
+     geom_hline(yintercept = 0, linetype = "dashed") +
+     scale_fill_discrete(
+         name = "",
+         limits = c("Total", "Direct", "Indirect"),
+         type = colour.list[c(3, 1, 2)]) +
+     scale_x_discrete(
+         name = "",
+         limits = c("Conventional", "Parametric MTE", "Semi-parametric MTE")) +
+     scale_y_continuous(expand = c(0, 0, 0.01, 0),
+         limits = c(-0.1, 8), breaks = seq(-10, 10, by = 1),
+         oob = scales::rescale_none,
+         name = "") +
+     ggtitle("Estimate, percent effect on subjective well-being") +
+     theme(plot.title = element_text(size = rel(1), hjust = 0),
+         plot.title.position = "plot",
+         plot.margin = unit(c(0, 3, 0.25, 0), "mm"),
+         legend.position = c(0.66, 0.9375),
+         legend.direction = "horizontal")
> # Save this file
> ggsave(file.path(figures.folder, "mediation-happy.png"),
+     plot = happy_mediation.plot,
+     units = "cm",
+     width = presentation.width, height = presentation.height)
> 
> 
> ################################################################################
> ## Same plot, but with empty plots for the MTE parts.
> 
> # Plot health results in a bar chart.
> health_mediation.placeholder <- Y_health.data %>%
+     filter(effect != "Percent Mediated") %>%
+     mutate(
+         pointest = ifelse(model == "Conventional", pointest, NA),
+         lowerest = ifelse(model == "Conventional", lowerest, NA),
+         upperest = ifelse(model == "Conventional", upperest, NA)) %>%
+     ggplot(aes(
+         fill = factor(effect, levels = c("Total", "Direct", "Indirect")),
+         x = model)) +
+     geom_bar(aes(y = pointest),
+         stat = "identity", position = "dodge", colour = "black",
+         na.rm = TRUE) +
+     geom_errorbar(aes(ymin = lowerest, ymax = upperest),
+         size = 2 / 3,
+         stat = "identity", position = position_dodge(0.9), width = 1 / 3,
+         na.rm = TRUE) +
+     theme_bw() +
+     geom_hline(yintercept = 0, linetype = "dashed") +
+     scale_fill_discrete(
+         name = "",
+         limits = c("Total", "Direct", "Indirect"),
+         type = colour.list[c(3, 1, 2)]) +
+     scale_x_discrete(
+         name = "",
+         limits = c("Conventional", "Parametric MTE", "Semi-parametric MTE")) +
+     scale_y_continuous(expand = c(0, 0, 0.01, 0),
+         limits = c(-0.1, 8), breaks = seq(-10, 10, by = 1),
+         oob = scales::rescale_none,
+         name = "") +
+     ggtitle("Estimate, percent effect on subjective health") +
+     theme(plot.title = element_text(size = rel(1), hjust = 0),
+         plot.title.position = "plot",
+         plot.margin = unit(c(0, 3, 0.25, 0), "mm"),
+         legend.position = c(0.66, 0.9375),
+         legend.direction = "horizontal")
> 
> # Save placeholder version
> ggsave(file.path(figures.folder, "mediation-health-placeholder.png"),
+     plot = health_mediation.placeholder,
+     units = "cm",
+     width = presentation.width, height = presentation.height)
> 
> # Plot happiness results in a bar chart.
> happy_mediation.placeholder <- Y_happy.data %>%
+     filter(effect != "Percent Mediated") %>%
+     mutate(
+         pointest = ifelse(model == "Conventional", pointest, NA),
+         lowerest = ifelse(model == "Conventional", lowerest, NA),
+         upperest = ifelse(model == "Conventional", upperest, NA)) %>%
+     ggplot(aes(
+         fill = factor(effect, levels = c("Total", "Direct", "Indirect")),
+         x = model)) +
+     geom_bar(aes(y = pointest),
+         stat = "identity", position = "dodge", colour = "black",
+         na.rm = TRUE) +
+     geom_errorbar(aes(ymin = lowerest, ymax = upperest),
+         size = 2 / 3,
+         stat = "identity", position = position_dodge(0.9), width = 1 / 3,
+         na.rm = TRUE) +
+     theme_bw() +
+     geom_hline(yintercept = 0, linetype = "dashed") +
+     scale_fill_discrete(
+         name = "",
+         limits = c("Total", "Direct", "Indirect"),
+         type = colour.list[c(3, 1, 2)]) +
+     scale_x_discrete(
+         name = "",
+         limits = c("Conventional", "Parametric MTE", "Semi-parametric MTE")) +
+     scale_y_continuous(expand = c(0, 0, 0.01, 0),
+         limits = c(-0.1, 8), breaks = seq(-10, 10, by = 1),
+         oob = scales::rescale_none,
+         name = "") +
+     ggtitle("Estimate, percent effect on subjective well-being") +
+     theme(plot.title = element_text(size = rel(1), hjust = 0),
+         plot.title.position = "plot",
+         plot.margin = unit(c(0, 3, 0.25, 0), "mm"),
+         legend.position = c(0.66, 0.9375),
+         legend.direction = "horizontal")
> 
> # Save placeholder version
> ggsave(file.path(figures.folder, "mediation-happy-placeholder.png"),
+     plot = happy_mediation.placeholder,
+     units = "cm",
+     width = presentation.width, height = presentation.height)
> 
> proc.time()
    user   system  elapsed 
1693.270    5.729 1707.907 
