
R version 4.5.1 (2025-06-13) -- "Great Square Root"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> #!/usr/bin/R
> ## Senan Hogan-Hennessy, 14 June 2025.
> ## Script to to extract relevant data from Oregon Health Insurance rep package.
> print(Sys.time())
[1] "2025-10-20 16:34:55 EDT"
> set.seed(47)
> 
> ## Packages:
> # functions for data manipulation and visualisation
> library(tidyverse)
── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──
✔ dplyr     1.1.4     ✔ readr     2.1.5
✔ forcats   1.0.0     ✔ stringr   1.5.1
✔ ggplot2   3.5.2     ✔ tibble    3.2.1
✔ lubridate 1.9.4     ✔ tidyr     1.3.1
✔ purrr     1.0.4     
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors
> # Functions for bootstrapping.
> library(boot)
> # Library for better colour choice and additional graphing.
> library(ggthemes)
> library(ggpattern)
> # Library for equations in plots
> library(latex2exp)
> 
> 
> # Define folder paths (1) input data (2) clean data.
> data.folder <- file.path("..", "..", "data", "oregon-lottery-icspr")
> figures.folder <- file.path("..", "..", "text", "sections", "figures")
> tables.folder <- file.path("..", "..", "text", "sections", "tables")
> presentation.folder <- file.path("..", "..", "presentation",
+     "presentation-files", "figures")
> # Size of figures.
> fig.width <- 15
> fig.height <- (2 / 3) * fig.width
> # List of 3 default colours.
> colour.list <- c(
+     "#1f77b4", # Blue
+     "#2ca02c", # Green
+     "#d62728") # Red
> 
> 
> ################################################################################
> ## Load the Oregon Health Insurance Experiment replication data.
> 
> # Load the pre-cleaned Oregon Health data.
> analysis.data <- data.folder %>%
+     file.path("cleaned-oregon-data.csv") %>%
+     read_csv()
Rows: 9957 Columns: 14
── Column specification ────────────────────────────────────────────────────────
Delimiter: ","
dbl (14): lottery_iv, hh_size, any_insurance, any_healthcare, initial_health...

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
> 
> # Factorise the relevant variables.
> analysis.data$hh_size <- factor(analysis.data$hh_size)
> analysis.data$initial_health_location <- factor(
+     analysis.data$initial_health_location)
> 
> 
> ################################################################################
> ## Validate the lottery encouragement instrument for having health insurance.
> 
> # Show lottery IV -> insurance is strong.
> iv_firststage.reg <- lm(any_insurance ~ 1 + lottery_iv,
+     weights = survey_weight,
+     data = analysis.data)
> print(summary(iv_firststage.reg))

Call:
lm(formula = any_insurance ~ 1 + lottery_iv, data = analysis.data, 
    weights = survey_weight)

Weighted Residuals:
    Min      1Q  Median      3Q     Max 
-0.9690 -0.3604 -0.3427  0.4562  1.2626 

Coefficients:
            Estimate Std. Error t value Pr(>|t|)    
(Intercept) 0.342750   0.006884   49.79   <2e-16 ***
lottery_iv  0.201082   0.009756   20.61   <2e-16 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 0.5248 on 9945 degrees of freedom
Multiple R-squared:  0.04097,	Adjusted R-squared:  0.04087 
F-statistic: 424.8 on 1 and 9945 DF,  p-value: < 2.2e-16

> 
> # Show lottery IV -> insurance is strong, conditional on household size.
> iv_firststage.reg <- lm(any_insurance ~ 1 + lottery_iv * factor(hh_size),
+     weights = survey_weight,
+     data = analysis.data)
> print(summary(iv_firststage.reg))

Call:
lm(formula = any_insurance ~ 1 + lottery_iv * factor(hh_size), 
    data = analysis.data, weights = survey_weight)

Weighted Residuals:
    Min      1Q  Median      3Q     Max 
-0.9757 -0.3568 -0.3394  0.5203  1.2421 

Coefficients:
                             Estimate Std. Error t value Pr(>|t|)    
(Intercept)                  0.339398   0.007899  42.966  < 2e-16 ***
lottery_iv                   0.234393   0.011542  20.308  < 2e-16 ***
factor(hh_size)2             0.014012   0.016012   0.875    0.382    
factor(hh_size)3            -0.339398   0.523824  -0.648    0.517    
lottery_iv:factor(hh_size)2 -0.108129   0.021775  -4.966 6.96e-07 ***
lottery_iv:factor(hh_size)3  0.467371   0.534930   0.874    0.382    
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 0.5238 on 9941 degrees of freedom
Multiple R-squared:  0.0452,	Adjusted R-squared:  0.04472 
F-statistic: 94.11 on 5 and 9941 DF,  p-value: < 2.2e-16

> 
> # Calculate Pr(Z_iv = 1 | household size), the known instrument prop score.
> iv_prop.reg <- lm(lottery_iv ~ 0 + factor(hh_size),
+     weights = survey_weight,
+     data = analysis.data)
> print(summary(iv_prop.reg))

Call:
lm(formula = lottery_iv ~ 0 + factor(hh_size), data = analysis.data, 
    weights = survey_weight)

Weighted Residuals:
    Min      1Q  Median      3Q     Max 
-1.1226 -0.4684 -0.4684  0.5316  0.9039 

Coefficients:
                 Estimate Std. Error t value Pr(>|t|)    
factor(hh_size)1 0.468419   0.005902   79.36   <2e-16 ***
factor(hh_size)2 0.568985   0.009371   60.72   <2e-16 ***
factor(hh_size)3 0.959136   0.108505    8.84   <2e-16 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 0.5368 on 9944 degrees of freedom
Multiple R-squared:  0.503,	Adjusted R-squared:  0.5028 
F-statistic:  3355 on 3 and 9944 DF,  p-value: < 2.2e-16

> 
> # Show mean rate of using healthcare
> analysis.data %>% pull(any_healthcare) %>% mean(na.rm = TRUE)
[1] 0.7324495
> table(pull(analysis.data, initial_health_location), exclude = NULL) / NROW(analysis.data)

         1          2          3          4          5          6          7 
0.35352014 0.30320378 0.06598373 0.10173747 0.04870945 0.07200964 0.05483579 
> # and it relates to usual location of care.
> print(summary(lm(any_healthcare ~ 1 + initial_health_location,
+     data = analysis.data)))

Call:
lm(formula = any_healthcare ~ 1 + initial_health_location, data = analysis.data)

Residuals:
    Min      1Q  Median      3Q     Max 
-0.7741 -0.5037  0.2289  0.2503  0.4963 

Coefficients:
                         Estimate Std. Error t value Pr(>|t|)    
(Intercept)               0.74972    0.00738 101.586  < 2e-16 ***
initial_health_location2  0.02140    0.01086   1.970   0.0488 *  
initial_health_location3  0.01588    0.01861   0.854   0.3933    
initial_health_location4 -0.07745    0.01561  -4.961 7.12e-07 ***
initial_health_location5 -0.10642    0.02121  -5.018 5.32e-07 ***
initial_health_location6  0.02434    0.01794   1.357   0.1749    
initial_health_location7 -0.24605    0.02014 -12.217  < 2e-16 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 0.4379 on 9950 degrees of freedom
Multiple R-squared:  0.02236,	Adjusted R-squared:  0.02177 
F-statistic: 37.93 on 6 and 9950 DF,  p-value: < 2.2e-16

> 
> 
> ################################################################################
> ## Create a figure showing the happiness + subjective health effects.
> 
> # Use the Abadie (2003) kappa weights to get E[ Y(z') | lottery complier ]
> abadie.late <- function(data, outcome, Z, Z_iv, control_iv,
+         indices = NULL){
+     # Bootstrap sample, if indices provided.
+     if (!is.null(indices)){
+         data <- data[indices,]
+     }
+     # Get the relevant variables.
+     outcome <- data[[outcome]]
+     Z          <- data[[Z]]
+     Z_iv       <- data[[Z_iv]]
+     control_iv <- data[[control_iv]]
+     # Estimate the kappa weighting
+     est_probZ_iv <- glm(Z_iv ~ 1 + control_iv)
+     hat_probZ_iv <- est_probZ_iv$fitted
+     kappa_0 <- (1 - Z) * (((1 - Z_iv) - (1 - hat_probZ_iv)) / 
+         ((1 - hat_probZ_iv) * hat_probZ_iv))
+     kappa_1 <- Z * ((Z_iv - hat_probZ_iv) / (
+         (1 - hat_probZ_iv) * hat_probZ_iv))
+     kappa <- kappa_0 * (1 - hat_probZ_iv) + kappa_1 * hat_probZ_iv
+     # Calculate the complier levels for z' = 0, 1, and resulting effect.
+     outcome_0_complier      <- mean(kappa_0 * outcome) / mean(kappa_0)
+     outcome_1_complier      <- mean(kappa_1 * outcome) / mean(kappa_1)
+     outcome_effect_complier <- outcome_1_complier - outcome_0_complier
+     return(c(outcome_0_complier, outcome_1_complier, outcome_effect_complier))
+ }
> 
> ## Estimate mean outcomes among lottery winners, with boot SEs
> boot.samples <- 1 * 10^3
> # Lottery effects (among entire population).
> Z.late <- boot(statistic = abadie.late, R = boot.samples,
+     data = analysis.data,
+     outcome = "any_insurance", Z = "lottery_iv",
+     Z_iv = "lottery_iv", control_iv = "hh_size")
> Z_0_complier      <- mean(Z.late$t[, 1], na.rm = TRUE)
> Z_1_complier      <- mean(Z.late$t[, 2], na.rm = TRUE)
> Z_effect_complier <- mean(Z.late$t[, 3], na.rm = TRUE)
> Z_0_complier.se      <- sd(Z.late$t[, 1], na.rm = TRUE)
> Z_1_complier.se      <- sd(Z.late$t[, 2], na.rm = TRUE)
> Z_effect_complier.se <- sd(Z.late$t[, 3], na.rm = TRUE)
> print(c(Z_effect_complier, Z_effect_complier.se))
[1] 0.217072348 0.009422776
> # Mediator: healthcare utilisation (among lottery compliers).
> D.late <- boot(statistic = abadie.late, R = boot.samples,
+     data = analysis.data,
+     outcome = "any_healthcare", Z = "lottery_iv",
+     Z_iv = "lottery_iv", control_iv = "hh_size")
> D_0_complier      <- mean(D.late$t[, 1], na.rm = TRUE)
> D_1_complier      <- mean(D.late$t[, 2], na.rm = TRUE)
> D_effect_complier <- mean(D.late$t[, 3], na.rm = TRUE)
> D_0_complier.se      <- sd(D.late$t[, 1], na.rm = TRUE)
> D_1_complier.se      <- sd(D.late$t[, 2], na.rm = TRUE)
> D_effect_complier.se <- sd(D.late$t[, 3], na.rm = TRUE)
> print(c(D_effect_complier, D_effect_complier.se))
[1] 0.042765016 0.008847816
> # Outcome: Health overall good? (among lottery compliers).
> Y_health.late <- boot(statistic = abadie.late, R = boot.samples,
+     data = analysis.data,
+     outcome = "Y_health", Z = "lottery_iv",
+     Z_iv = "lottery_iv", control_iv = "hh_size")
> Y_health_0_complier      <- mean(Y_health.late$t[, 1], na.rm = TRUE)
> Y_health_1_complier      <- mean(Y_health.late$t[, 2], na.rm = TRUE)
> Y_health_effect_complier <- mean(Y_health.late$t[, 3], na.rm = TRUE)
> Y_health_0_complier.se      <- sd(Y_health.late$t[, 1], na.rm = TRUE)
> Y_health_1_complier.se      <- sd(Y_health.late$t[, 2], na.rm = TRUE)
> Y_health_effect_complier.se <- sd(Y_health.late$t[, 3], na.rm = TRUE)
> print(c(Y_health_effect_complier, Y_health_effect_complier.se))
[1] 0.063078527 0.009934009
> # Outcome: Happy overall?  (among lottery compliers).
> Y_happy.late <- boot(statistic = abadie.late, R = boot.samples,
+     data = analysis.data,
+     outcome = "Y_happy", Z = "lottery_iv",
+     Z_iv = "lottery_iv", control_iv = "hh_size")
> Y_happy_0_complier      <- mean(Y_happy.late$t[, 1], na.rm = TRUE)
> Y_happy_1_complier      <- mean(Y_happy.late$t[, 2], na.rm = TRUE)
> Y_happy_effect_complier <- mean(Y_happy.late$t[, 3], na.rm = TRUE)
> Y_happy_0_complier.se      <- sd(Y_happy.late$t[, 1], na.rm = TRUE)
> Y_happy_1_complier.se      <- sd(Y_happy.late$t[, 2], na.rm = TRUE)
> Y_happy_effect_complier.se <- sd(Y_happy.late$t[, 3], na.rm = TRUE)
> print(c(Y_happy_effect_complier, Y_happy_effect_complier.se))
[1] 0.081979498 0.009426907
> 
> 
> ################################################################################
> ## Bar chart of the health insurance effects
> 
> # Name of the outcome variables (in order)
> outcome_name.list <- c(
+     "0               1\nHealth insured?",
+     "0               1\nAny use of healthcare?",
+     "0               1\nSurvey: \nHealth overall good?",
+     "0               1\nSurvey: \nHappy overall?")
> 
> alpha <- 0.05
> # Get a dataframe of the relevant effects.
> complier.data <- data.frame(
+     Z_iv = c("0", "1"),
+     outcome_value = c(
+         Z_0_complier, Z_1_complier,
+         D_0_complier, D_1_complier,
+         Y_health_0_complier, Y_health_1_complier,
+         Y_happy_0_complier, Y_happy_1_complier),
+     ci_lower = c(
+         quantile(Z.late$t[, 1], alpha / 2, na.rm = TRUE),
+         quantile(Z.late$t[, 2], alpha / 2, na.rm = TRUE),
+         quantile(D.late$t[, 1], alpha / 2, na.rm = TRUE),
+         quantile(D.late$t[, 2], alpha / 2, na.rm = TRUE),
+         quantile(Y_health.late$t[, 1], alpha / 2, na.rm = TRUE),
+         quantile(Y_health.late$t[, 2], alpha / 2, na.rm = TRUE),
+         quantile(Y_happy.late$t[, 1], alpha / 2, na.rm = TRUE),
+         quantile(Y_happy.late$t[, 2], alpha / 2, na.rm = TRUE)),
+     ci_upper = c(
+         quantile(Z.late$t[, 1], 1 - alpha / 2, na.rm = TRUE),
+         quantile(Z.late$t[, 2], 1 - alpha / 2, na.rm = TRUE),
+         quantile(D.late$t[, 1], 1 - alpha / 2, na.rm = TRUE),
+         quantile(D.late$t[, 2], 1 - alpha / 2, na.rm = TRUE),
+         quantile(Y_health.late$t[, 1], 1 - alpha / 2, na.rm = TRUE),
+         quantile(Y_health.late$t[, 2], 1 - alpha / 2, na.rm = TRUE),
+         quantile(Y_happy.late$t[, 1], 1 - alpha / 2, na.rm = TRUE),
+         quantile(Y_happy.late$t[, 2], 1 - alpha / 2, na.rm = TRUE)),
+     outcome_name = c(
+         rep(outcome_name.list[1], 2),
+         rep(outcome_name.list[2], 2),
+         rep(outcome_name.list[3], 2),
+         rep(outcome_name.list[4], 2)))
> 
> # Full barchart
> complier.plot <- complier.data %>%
+     ggplot(aes(x = outcome_name, group = Z_iv)) +
+     #geom_bar(aes(group = Z_iv,
+     #    fill = outcome_name, x = outcome_name, y = outcome_value),
+     #    colour = 1, position = "dodge", stat = "identity") +
+     geom_col_pattern(
+         aes(pattern = Z_iv, fill = outcome_name, y = outcome_value),
+         position = "dodge",
+         pattern_angle = 45,
+         pattern_density = 0.01,
+         pattern_spacing = 0.1,
+         pattern_fill = "black",
+         colour = "black") +
+     geom_errorbar(aes(x = outcome_name, ymin = ci_lower, ymax = ci_upper),
+         size = 0.5, alpha = 0.5,
+         stat = "identity", position = position_dodge(0.9), width = 1 / 3) +
+     theme_bw() +
+     scale_x_discrete(name = "", limits = outcome_name.list) +
+     scale_fill_manual("", values = colour.list[c(2, 1, 3, 3)]) +
+     scale_y_continuous(expand = c(0, 0),
+         name = "",
+         limits = c(0.275, 0.825), oob = scales::rescale_none,
+         breaks = seq(0, 1, by = 0.1)) +
+     ggtitle(TeX(r"(Mean Outcome, for each $z' =0,1$.)")) +
+     theme(legend.position = "none",
+         plot.title = element_text(hjust = 0, size = rel(1)),
+         plot.title.position = "plot",
+         plot.margin = unit(c(0, 0, -2.5, 0), "mm"))
Warning message:
Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.
ℹ Please use `linewidth` instead. 
> # Annotate
> offset.text <- 0.05
> complier.plot <- complier.plot +
+     # Label the effect sizes.
+     annotate("text", x = 0.8, y = offset.text + Z_0_complier + Z_effect_complier / 2,
+         label = paste0("+ ", round(Z_effect_complier, 2),
+             "\n(", round(Z_effect_complier.se, 2), ")"),
+         size = 4, hjust = 0.5, vjust = 0.5,
+         fontface = "bold", colour = colour.list[1]) +
+     annotate("text", x = 1.8, y = offset.text + D_0_complier + D_effect_complier / 2,
+         label = paste0("+ ", round(D_effect_complier, 2),
+             "\n(", round(D_effect_complier.se, 2), ")"),
+         size = 4, hjust = 0.5, vjust = 0.5,
+         fontface = "bold", colour = colour.list[2]) +
+     annotate("text", x = 2.8, y = offset.text + Y_health_0_complier + Y_health_effect_complier / 2,
+         label = paste0("+ ", round(Y_health_effect_complier, 2),
+             "\n(", round(Y_health_effect_complier.se, 2), ")"),
+         size = 4, hjust = 0.5, vjust = 0.5,
+         fontface = "bold", colour = colour.list[3])  +
+     annotate("text", x = 3.8, y = offset.text + Y_happy_0_complier + Y_happy_effect_complier / 2,
+         label = paste0("+ ", round(Y_happy_effect_complier, 2),
+             "\n(", round(Y_happy_effect_complier.se, 2), ")"),
+         size = 4, hjust = 0.5, vjust = 0.5,
+         fontface = "bold", colour = colour.list[3])
> # Save this plot
> ggsave(file.path(figures.folder, "insurance-effects.png"),
+     plot = complier.plot,
+     units = "cm", width = fig.width, height = fig.height)
> 
> ################################################################################
> ## Make the plot simpler for a presentation.
> 
> # Limited barchart
> complier.plot <- complier.data %>%
+     filter(outcome_name != "0               1\nSurvey: \nHappy overall?") %>%
+     ggplot(aes(group = Z_iv,
+         fill = outcome_name, x = outcome_name, y = outcome_value)) +
+     geom_col_pattern(aes(pattern = Z_iv),
+         position = "dodge",
+         pattern_angle = 45,
+         pattern_density = .01,
+         pattern_spacing = .1,
+         pattern_fill = "black",
+         colour = "black") +
+     #geom_col_pattern(aes(colour = 1,
+     #    pattern = Z_iv, pattern_type = Z_iv)) + #, position = "dodge", stat = "identity") +
+     theme_bw() +
+     scale_x_discrete(name = "", limits = outcome_name.list[1:3]) +
+     scale_fill_manual("", values = colour.list[c(2, 1, 3)]) +
+     scale_y_continuous(expand = c(0, 0),
+         name = "",
+         limits = c(0.275, 0.825), oob = scales::rescale_none,
+         breaks = seq(0, 1, by = 0.1)) +
+     ggtitle(TeX(r"(Mean Outcome, for each $z' =0,1$.)")) +
+     theme(legend.position = "none",
+         plot.title = element_text(hjust = 0, size = rel(1)),
+         plot.title.position = "plot",
+         plot.margin = unit(c(0, 0, -2.5, 0), "mm"))
> # Annotate
> complier.plot <- complier.plot +
+     # Label the effect sizes.
+     annotate("text", x = 0.8, y = offset.text + Z_0_complier + Z_effect_complier / 2,
+         label = paste0("+ ", round(Z_effect_complier, 2),
+             "\n(", round(Z_effect_complier.se, 2), ")"),
+         size = 4, hjust = 0.5, vjust = 0.5,
+         fontface = "bold", colour = colour.list[1]) +
+     annotate("text", x = 1.8, y = offset.text + D_0_complier + D_effect_complier / 2,
+         label = paste0("+ ", round(D_effect_complier, 2),
+             "\n(", round(D_effect_complier.se, 2), ")"),
+         size = 4, hjust = 0.5, vjust = 0.5,
+         fontface = "bold", colour = colour.list[2]) +
+     annotate("text", x = 2.8, y = offset.text + Y_health_0_complier + Y_health_effect_complier / 2,
+         label = paste0("+ ", round(Y_health_effect_complier, 2),
+             "\n(", round(Y_health_effect_complier.se, 2), ")"),
+         size = 4, hjust = 0.5, vjust = 0.5,
+         fontface = "bold", colour = colour.list[3])
> 
> # Save this plot for the presentation (different size).
> presentation.width <- 15
> presentation.height <- (7 / 12) * presentation.width
> ggsave(file.path(presentation.folder, "insurance-effects.png"),
+     plot = complier.plot,
+     units = "cm", width = presentation.width, height = presentation.height)
> 
> proc.time()
   user  system elapsed 
 42.179   0.748  43.397 
